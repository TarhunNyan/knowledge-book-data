# Устройство Linux

# Файловая система

Все папки находятся внутри одной корневой папки(обозначется как /). Нет деления на диски как в windows

## home - папка

Папка для пользователей. Для каждого пользователя создается своя папка в каталоге home. Путь до папки текущего юзера записывается как - ~

Тут храниться:

-   ~/.profile - профайл консоли. Когда запускаешь консоль, запускается и профайл

## var - папка

Тут храниться:

-   /var/log/... - тут храняться все логи
-   /var/log/wtmp - содержащий записи о всех входах и выходах из системы

Есть еще логи ядра Linux, они не записываются а храняться в оперативке. Посмотреть логи можно только используя:

```bash
dmesg
```

## media - папка

Папки в папке media, представляют из себя что-то вроде дисков из windows. Подключаемые устройства появляются именно в media

## etc - папка

Папка со всем подряд:

-   /etc/passwd - список пользователей
-   /etc/shadow - пароли и управление паролями пользователей
-   /etc/group - список групп
-   /etc/apt/sources.list - список репозиториев

## Спрятанные папки/файлы

Чтобы файл/папка был спрятан, первым символом в названии должна стоять '.'

## Пути

Абсолютный путь. Начинается от корневой папки:

```bash
/home/denis/folder
```

Относительный путь. Переходим из /home/denis в /home/vasia:

```bash
../vasia
```

Относительный путь. Переходим из /home/denis в /home/denis/folder:

```bash
./folder
```

Относительно домашней директории текущего пользователя. Переходим из /etc/log в /home/denis/folder:

```bash
~/folder
```

Многие команды Linux поддерживают микро-регулярки:

-   \* - набор любых символов. Например, все файлы начинющиеся на file: /folder/file*.*
-   ? - один любой символ или ничего. Например, получить file, file1, ... file9: /folder/file?.\*

# Пользователи

В Linux есть пользователи и группы пользователей. Пользователь может принадлежать группе. Эта система нужна чтобы:

-   настраивать доступ пользователей и групп [к папкам и файлам]()
-   дать права администратора, то есть права на использование sudo(super user do)

## Команды стандартного рабочего процесса

Показать имя текущего пользователя:

```bash
whoami
# => userName
```

Поменять пользователя:

```bash
# su - switch user
su vasya
```

Поменять дирректорию со скриптами. Иначе командная строка работает не так как положенно:

```bash
usermod --shell /bin/bash user_name
```

Информация о текущем пользователе. В примере:

-   uid=1000(denis) - userID
-   gid=1000(denis) - groupID
-   groups - группы к которым принадлежит пользователь. Самая интересная это sudo. Означает что у тебя есть права суперпользователя

```bash
id
# => uid=1000(userName) gid=1000(userName) groups=1000(userName),4(adm),27(sudo),...
```

Информация о конкретном пользователе. В примере:

-   uid=1000(denis) - userID
-   gid=1000(denis) - groupID
-   groups - группы к которым принадлежит пользователь. Самая интересная это sudo. Означает что у тебя есть права суперпользователя

```bash
id userName
# => uid=1000(userName) gid=1000(userName) groups=1000(userName),4(adm),27(sudo),...
```

## Отслеживание пользователей

Показать последние входы в систему пользователей:

```bash
last
# => mensh    pts/0        5.183.230.110    Sun Jul 17 15:02   still logged in
# => mensh    pts/0        5.183.230.110    Sun Jul 17 06:27 - 06:28  (00:00)
# => ...
```

Какие пользователи сейчас залогинены:

```bash
who
# => Имя пользователя      Имя терминальной линии      Начало сеанса
# => userName              tty7                        2019-10-19 09:09
# => userName              pts/1                       2019-10-19 13:40
# => ...
```

Какие пользователи залогинены и что делают:

```bash
w
# => 21:08:29 up 9 min, 1 user, load average: 0,08, 0,45, 0,43
# => Имя пользователя | Назв терминала | Назв удаленного ПК(IP) | t входа | t бездействия | t какое-то | t секое-то | Командная строка текущего процесса
# => pingvinu          :0                :0                       21:00     ?xdm?           16.19s       0.00s        /usr/lib/
# => ...
```

## Управление пользователями

Создаем пользователя:

```bash
sudo useradd -m userName
# автоматически создает папку с именем пользователя в home
# пользователь не сможет зайти в систему пока ему не будет назначен пароль
```

Меняем/задаем пароль пользователя:

```bash
sudo passwd userName
# после команды консоль просит ввести пароль
```

Удалить пользователя:

```bash
sudo userdel userName
# оставляет папку пользователя в home нетронутой
```

Удалить пользователя и его папку:

```bash
sudo userdel -r userName
# удаляет пользователя и его папку в home
```

## Управление группами

Создать группу:

```bash
sudo groupadd groupName
```

Удалить группу:

```bash
sudo groupdel groupName
```

Добавить пользователя в группу. В данном примере:

-   usermod - модифицировать пользователя
-   -aG - два флага: a - добавить, G - группу
-   groupName - имя группы
-   userName - имя пользователя

```bash
sudo usermod -aG groupName userName
```

Удалить пользователя из группы:

```bash
sudo deluser userName groupName
```

# Как хранится система групп и пользователей

## Пользователи

При создании пользователя ему создается папка. В эту папку копируются все файлы и папки из:

```bash
/etc/skel/
```

Все пользователи храняться в /etc/passwd:

```bash
cat /etc/passwd
# => kolya:x:1003:1003:Description:/home/kolya:/bin/bash
# => petia:x:1003:1003::/home/petia:/bin/bash
# => ...
```

Расшифровка содержания /etc/passwd:

-   kolya - имя пользователя
-   x - указание что пароль в другом месте
-   1003 - номер userID
-   1003 - номер groupID
-   Description - описание пользователя(комментарий)
-   /home/kolya - домашняя директория
-   /bin/bash - дирректория со скриптами

## Пароли пользователей

Пароли в зашифрованном виде хранятся в /etc/shadow:

```bash
sudo cat /etc/shadow
# => kolya:psdfjkOSA6...:17125:0:99999:7:14::
# => ...
```

Расшифровка содержания /etc/shadow:

-   kolya - имя пользователя
-   psdfjkOSA6... - зашифрованный пароль
-   17125 - дата последнейго изменения пароля. Дата считается с 1 января 1971
-   0 - через сколько дней можно поменять пароль
-   99999 - срок действия пароля
-   7 - начнет предупреждать за 7 дней до прекращения действия пароля, что его надо сменить
-   14 - количество дней до бана, после истечения срока действия пароля
-   ... - дата когда учетная запись была отключена
-   ... - не используется

## Группы

Информация о группах пользователей хранится в /etc/group:

```bash
cat /etc/group
# => adm:x:4:syslog,denis,kolya
# => ...
```

Расшифровка содержания /etc/shadow:

-   adm - имя группы(afm - группа, администраторов)
-   x - зашифрованный пароль
-   4 - groupID
-   syslog,denis,kolya - пользователи входящие в группу

# Владение

То какие права доступны пользователям, группам и всем остальным

## Пользователь и группы

Посмотреть пользователя(user) и группу(group) файла/папки:

```bash
ls -l
# => -rw-rw-r--   1    user   group  150   окт 6 13:13   1.txt
# => ...
```

Меняем владельца файла/папки:

```bash
# chown - change ownership
sudo chown userName /path
```

Меняем группу файла/папки:

```bash
# chown - change group
sudo chgrp groupName /path
```

## Посмотреть права

Команда ls выводит список файлов/папок. Если использовать флаг l, то к названию файлов/папок добавиться дополнительная информация. Нас интересует первый столбец:

```bash
ls -l
# => -rw-rw-r--   1    user   group  150   окт 6 13:13   1.txt
# => ...
```

Разберем данные из первого столбца:

```bash
#     -          rw-          rw-         r--
#     ^           ^            ^           ^
# 1 символ    u группа     g группа     o группа
```

Итак:

-   1 символ - указывает на то является файлом/директорией/ссылкой
-   u группа - разрешения для user
-   g группа - разрешения для group
-   o группа - разрешения для outer(все остальные)

У групп есть три флага:

-   r - read. Просмотр файла/папки
-   w - write. Запись/изменения/создание файла
-   x - execute:
    -   для директории - в директорию можно заходить
    -   для скрипта - будет исполняться если просто указать путь

## Редактирование прав

Редактирование прав идет через команду chmod. Например, уберем право пользователя на запись:

```bash
# chmod - change modifiers
sudo chmod u-w /path
```

Убрать доступ на запись:

```bash
# убираем(-) право пользователя(u) на запись(w)
sudo chmod u-w /path
# убираем(-) право группы(g) на запись(w)
sudo chmod g-w /path
# убираем(-) право для всех остальных(o) на запись(w)
sudo chmod o-w /path
```

Добавить доступ на чтение:

```bash
# добавляем(+) право пользователя(u) на чтение(r)
sudo chmod u+r /path
# добавляем(+) право группы(g) на чтение(r)
sudo chmod g+r /path
# добавляем(+) право для всех остальных(o) на чтение(r)
sudo chmod o+r /path
```

Сделать сразу несколько изменений прав:

```bash
sudo chmod g+w,u-r,o-w,o-r /path
```

## Задание прав

Чтобы задать права, права нужно задавать сразу пользователю(u), группе(g) и остальным(o). Делается это через числа

Представь что rwx просто набор бит-флагов. Например:

```bash
# rw- r-- -wx
# 110 100 011
#   6   4   3
sudo chmod 643 /path
```

## StickyBit

Если к папке есть права, а к файлу нет, то пользователь может удалить файл из папки, хотя по логике не должен. Для решения проблемы был создан stickyBit

Обозначается t, работает только для остальных(o):

```bash
sudo chmod o-t /path
```

Если задается числовым методом, то первое число должно быть 1 или 0:

```bash
sudo chmod 1777 /path
```

# FAQ по командам

## База

Перед вводом комманды, терминал вам показывает что-то вроде:

```bash
tarhunnyan@MyLinux:~$
```

В данном случае:

-   tarhunnyan - имя пользователя
-   MyLinux - сервер на котором сейчас находимся
-   ~ - тут прорисан путь в котором находимся
-   $ - приглашение ввести команду

## Команда

Просто команда:

```bash
command
```

Команда + значение:

```bash
command value
```

## Длинная опции

Длинная опция(флаг):

```bash
command --long-option
command --no-long-option
```

Длинная опция(с параметром):

```bash
command --long-option 10
command --long-option=10
```

## Короткая опции

Это то же что и длинная, но при частом написании одних и тех же комманд, устаешь и ошибаешся. Поэтому для пользователя есть сокращенный вариант опций. В СКРИПТАХ используют длинные названия, для читаемости

Короткая опция(флаг):

```bash
util -l
```

Короткая опция(набор флагов):

```bash
util -l -a -s
util -las
```

Короткая опция(с параметром):

```bash
util -l 10
util -l=10
util -l10
```

## Стандартные опции

| Имя | Сокращенный аналог | Описание                                                    |
| :-- | :----------------- | :---------------------------------------------------------- |
|     | -a                 | Вывести все объекты                                         |
|     | -c                 | Произвести подсчёт                                          |
|     | -d                 | Указать директорию                                          |
|     | -e                 | Развернуть объект                                           |
|     | -f                 | Указать файл, из которого нужно прочитать данные            |
|     | -h                 | Вывести справку по команде                                  |
|     | -i                 | Игнорировать регистр символов                               |
|     | -l                 | Выполнить полноформатный вывод данных                       |
|     | -n                 | Использовать неинтерактивный (пакетный) режим               |
|     | -o                 | Позволяет указать файл, в который нужно перенаправить вывод |
|     | -q                 | Выполнить скрипт в quiet режиме                             |
|     | -r                 | Обработать папки и файлы рекурсивно                         |
|     | -s                 | Выполнить скрипт в silent режиме                            |
|     | -v                 | Выполнить многословный вывод                                |
|     | -x                 | Исключить объект                                            |
|     | -y                 | Ответить "yes" на все вопросы                               |

# Получение документации по командам

## О команде man

Иногда в результате поиска по мануалу будут возле команд цифры в скобках. Это разделы руководства. Например:

```bash
man -f man
# man (1)   -    Description...
# man (7)   -    Description...
```

Чтобы сразу попасть в раздел нужно его указать, в примере 7 раздел:

```bash
man 7 man
```

Для поиска команд по ключевым словам:

```bash
man -k time
```

В данном примере:

-   man - команда мануала
-   k - параметр поиска по ключевым словам
-   time - ключевое слово

## Информация о команде

Выведет мануал по комманде time:

```bash
man time
```

## Краткое описание команды

Краткое описание команды

```bash
whatis time
```

## Расположение исполняемого файла

Расположение исполняемого файла/пакета:

```bash
whereis time
```

# Установка пакетов(програм)

Команды отличаются в зависимости от Linux'а, точнее от менеджера пакетов. Но принцип в них одинаковый, да и крупных менеджеров пакетов всего два:

-   apt-get
-   yum

## Откуда устанавливаются пакеты

Любителями Linux создаются репозитории. Это типа GooglePlay, но в мире Linux. И ваша система хранит адресса некоторых репозиториев, в которых ищет интересующую вас софтину

Список репозиториев:

```bash
cat /etc/apt/sources.list
```

## Обновление репозиториев

Обновление репозиториев:

```bash
sudo apt-get update
```

## Установка пакета

```bash
sudo apt-get install programName
```

## Удаление пакета

```bash
sudo apt-get remove programName
```

## Усатновить пакет без менеджера

Находим в интернете файл, для Ubuntu должен иметь разрешение .deb. Качаем его:

```
wget http://.../.../filename.deb
```

Устанавливаем:

```bash
sudo dpkg -i /.../.../filename.deb
```

## Удалить пакет без менеджера

Стираем:

```bash
sudo dpkg -r packageName
```

# Environment Variable

Environment Variable - переменные окружения. Вообще делится на две группы:

-   "переменные окружения" - доступна в текущем окружении и в дочерних сеансах
-   "переменные оболочки" - доступна только в текущем сеансе

## EnvVar - env

env - позволяет получить список всех "переменные окружения" и их значения:

```bash
env
```

Изменить "переменную окружения" для одной комманды:

-   env VAR1="value" - задаем для следующей команды переменную VAR1 со значение value
-   ls -a - стандартная комманда с параметрами как обычно

```bash
env VAR1="value" ls -a
```

## EnvVar - printenv

printenv - получить значение "переменные окружения":

-   printenv - комманда
-   SHELL - переменная значение которой получаем

```bash
printenv SHELL
```

## EnvVar - set

Вывод "переменных окружения" и "переменных оболочки":

```bash
(set -o posix; set)
```

Получение значения "переменной оболочки":

```bash
set | grep TEST_VAR
# => TEST_VAR="value"
```

## EnvVar - Создание "переменной оболочки"

Создаем "переменную оболочки":

-   TEST_VAR - имя переменной
-   'Hello World!' - значение переменной

```bash
TEST_VAR='Hello World!'
```

## EnvVar - Создание "переменной окружения"

Создаем "переменную окружения":

-   TEST_VAR='Hello World!' - создаем "переменную оболочки"
-   export - делаем "переменную оболочки", "переменной окружения"
-   export NEW_VAR="Testing export" - создаем "переменную окружения" за один шаг

```bash
TEST_VAR='Hello World!'
export TEST_VAR
export NEW_VAR="Testing export"
```

## EnvVar - Использование EnvVar

Для использование EnvVar:

-   $ - указываем, что надо подставить значение из EnvVar
-   TEST_VAR - имя подставляемой переменной

```bash
echo $TEST_VAR
```

# Выключение Linux

## Выключить Linux

```bash
sudo shutdown now
```

## Перезагрузить Linux

```bash
sudo reboot now
```
