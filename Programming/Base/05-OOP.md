# ООП

# Принципы ООП

Абстракция - это способ выделить набор полей и методов, единых для всех объектов в отдельную сущность

-   class - абстракция для объекта
-   class - может быть абстракцией для другого класса

Инкапсуляция - объединение в одном месте данных и методов:

-   класс является капсулой, в которую кладутся и методы и свойства
-   это кажется очевидным, но из контекста процедурного программирования, это не так

Сокрытие - относится к инкапсуляции. Позволяет скрывать поля и методы объекта от других

-   скрывает методы и поля от пользователя, потому что эти методы и поля внутренние и нужны для функционирования класса

Наследование - это концепция, согласно которой одни классы, называемые родительскими, могут лежать в основе других классов, называемых дочерними:

-   родитель - более общий Class
-   потомок - более специфичный

Полиморфизм - (принимающий много форм)способность объекта использовать методы родительского класса, даже если родителя не существует

-   есть полиморфизм методов. Когда можно выполнить перегрузку метода, но это не "правильный" полиморфизм

# SOLID

Single Responsibility(SRP) - один класс, одна задача

-   то есть, никаких огромных многозадачных классов

Open Closed(OCP) - программные сущности должны быть открыты для расширения, но закрыты для изменения

-   то есть мы добавляем новую сущность, по средствам композиции, наследования...

Liskow Substitution(LSP) - сущности использующие родительский тип, должны так же работать и с наследниками

Interface Segregation (ISP) - программные сущности не должны зависить от методов которые они НЕ используют

Dependency Inversion(DIP) - модули высокого уровня не должны зависить от модулей более низкого уровня

-   объекты должны взаимодействовать через интерфейсы и не думать как работают объекты к которым они обращаются внутри
-   короче, больше декораторов

#

## Отношения объектов

1. Сильная ассоциация типа "Is A". По человечески - Inheritance(наследование). Например: Car -> Honda
2. Ассоциация типа "Has A"
   a. Сильная. По человечески - Composition. Например: у человека есть сердце. Если убрать сердце то человек умрет
   б. Слабая. По человечески - Aggregation. Каждый класс сущесвтует сам по себе, хотя между нимим есть какие-то отношения

# Паттерны

## Entity-Attribute-Value(EAV)

Шаблон для ДБ ориентированных систем. Суть в том, что есть табличка для:

-   Entity(сущностей)

| ID  | Name    |
| :-- | :------ |
| 1   | SSD     |
| 2   | HDD     |
| 3   | SSD/HDD |

-   Attribute(аттрибуты)

| ID  | Entity | Name  | IsNum |
| :-- | :----- | :---- | :---- |
| 1   | 2      | Size  | 1     |
| 2   | 1      | Size  | 1     |
| 3   | 1      | Color | 0     |

-   Value(значения) - задает Value, связывает Attribute и Entity

| Instance_ID | Entity_ID | Attribute_ID | Text_value | Num_vaue |
| :---------- | :-------- | :----------- | :--------- | :------- |
| 1           | 2         | 2            |            | 300      |
| 2           | 1         | 1            |            | 0        |
| 1           | 2         | 2            |            | 100      |
| 3           | 1         | 3            | red        |          |
| 3           | 1         | 3            | green      |          |

## Abstract factory - Абстрактная фабрика

Abstract factory - паттерн(пораждающий). Используется когда надо создавать сильно похожие объекты, но реализованные по разному

Пример: у нас фабрика для btn(win), btn(mac), checkbox(win) и checkbox(mac). Мы создаем Abstract factory, которая при инициализации будет определять, на win или mac мы находимся и вызывать нужную фабрику

## Adapter - Адаптер

Adapter - паттерн(структурный) прослойка которая адаптирует выходные данные из первого Object во входные данные во второй Object

## Iterator - Итератор

Iterator - паттерн(поведенческий) который позволяет иттерироваться нестандартными способами по сложным структурам

Пример: сейчас достаточно обходить дерево в глубину, но потом потребуется возможность перемещаться по дереву в ширину. А на следующей неделе и того хуже — понадобится обход коллекции в случайном порядке. Решение: создай интерфейс для итератора (там как минимум должна быть функция получения элемента), для каждого способа иттерирования создавай свой класс расширенный от итератора. Каждый класс в конструкторе принимает, коллекцию по которой будет иттерироваться. Ну а дальше, иттерируйся как душа скажет

## Command - Команда

Command - паттерн(поведенческий) шаблон отвечающий за события. Так же связующий между интерфейсом и логикой. Бонусом идёт возможность логирования, а также ведение истории вызванных комманд

Пример: мы сдаём интерфейс Command, где в идеале, (не в идеале undo, backup и что захочешь) определен один метод - execute. В реализации интерфейса описываем что делает execute и радуемся жизни. Вопрос только с данными, execute получает данные из родительского класса

## Composite - Компоновщик

Composite - паттерн(структурный) Это просто дерево. Единственное ограничение паттерна, что контейнер где хранятся элементы и сам элемент должны наследовать один класс(или интерфейс). Это связано с тем, что пользователь не должен видеть разницы между контейнером и элементом. В общем у контейнера в отличии от элемента должно быть пару методов типа добавить, удалить и т.д.

## Interpretator - Интерпретатор

Interpretator - паттерн(поведенческий) является реализацией языка с бинарными(это не точно) операторами. Паттерн схож с компановщик, разделен на три класса:

-   контекст - дерево операторов
-   нетерминальное выражение - операция/действие(по факту узел дерева). Унаследован от класса выражения
-   терминальное выражение - символ/значение(по факту лист дерева). Унаследован от класса выражения

## Bridge - Мост

Bridge - паттерн(структурный паттерн) в котором есть две отдельные иерархии - абстракция(например GUI) и реализация(например Logic). Теперь мы можем прокинуть абстракцию в объекты классов реализации и вызывать нужные нам методы и поля.

Пример: в вебе абстракция = тема. А реализация = условный реакт-код. После такого, мы не только можем отдельно редактировать стили от логики, но и в runtime менять темы. Так же прикол в том что логик может быть много и наследуясь от реализации все классы будут иметь доступ к абстракции

## Observer - Наблюдатель

Observer - паттерн(поведенческий) создаётся объект с тремя базывами функциями и Map:

-   Map - хранит данные где: key - имя события, value - массив объектов подписанных на события
-   Subscribe - функция подиски объектом на событие
-   Unsubscribe - отписка от события
-   Send - функция которая сообщает всем subscribers что событие произошло и вызывает у всех subscribers объектов некоторую функцию(едина для всех объектов), которая принимает имя события

## Singleton - Одиночка

Singleton - паттерн(пораждающий) к этому паттерну только одно требование, чтобы объект класса можно было создать только один раз, так что если объект нужно создавать только один раз, то тебе к этому паттерну

## Visitor - Посетитель

Visitor - паттерн(поведенческий) обходит дерево

Пример: есть дерево из объектов разных классов. Его надо обойти и создать xml. Менять поведение внутри самих этих классов - некамильфо, так ещё и может сделать классы нестабильными. Поэтому создаём новый класс, visitor. В нем, для каждого класса присутствующего в дереве, создаём метод, принимающий именно этот класс из дерева. В самих классах дерево добавляем метод accept принимающий visitor (visitor может быть несколько, например надо ещё и в pdf экспортировать), а уже этот метод вызывает в visitor нужный метод принимающий this класс

## Mediator - Посредник

Mediator - паттерн(поведенческий) контроллирующий поведение между несколькими объектами

Пример: у нас есть много объектов со сложными связями. Это неудобно. Поэтому создаем посредника и пусть объекты отправляют в него данные, а он уже решает что с ними делать! Все объекты должны иметь ссылку на посредника, посредник должен иметь ссылки на все объекты

## Flyweight - Приспособленец/Легковес

Flyweight - паттерн(структурный) если много однотипных объектов, то можно применить Легковес. Статичные данные, которые не меняются (например текстуры одинаковых НПС) выносятся в отдельный объект, и на них хранятся только ссылки. А нестатичные данные (типо координат) остаются в самом объекте. И ещё, обязательно нужна фабрика для статичных объектов, чтобы знать, когда создать новый, а когда вернут ссылку

## Prototype - Прототип

Prototype - паттерн(пораждающий), который позволяет создавать копию объекта. Это может помочь ускорить код (если поля нового объекта долго вычисляются) или упростить инициализацию (создаёшь копию и уже в ней меняешь нужные поля). Вся суть в методе (интерфейса с описанным методом) copy. Который вызывается если надо скопировать объект

## Memento - Снимок/Хранитель

Memento - паттерн, который хранит состояние объекта и может его восстанавливать. Из минусов жрет очень много памяти.

Пример: в объекте снимки которого хотим сделать, создаём метод backup и restore. Backup упаковывает поля объекта(например в byteArray), а restore из объекта backup - восстанавливает поля. Также создаётся класс memento, который хранит в себе ссылку на объект и его снимок, а также может восстановить состояние. А дальше дело с этим что хочешь

## State - Состояние

State - паттерн(поведенческий)

Пример: есть аудиоплеер и у него три состояния: заблокирован, разблокирован, музыка играет. Для этих состояний создаётся общий интерфейс. Для каждого состояния создаётся класс расширенный этим интерфейсом. Определяется контекст(место где хранятся и вызываются состояния). Дальше мы уже переключаем состояния либо внутри созданных классов либо вне их

## Strategy - Стратегия

Strategy - паттерн(поведенческий)

Пример: есть навигатор и он может прокладывать путь от точки А к точке Б несколькими способами. Каждый такой способ заносим в отдельный класс, но естественно с одинаковыми интерфейсами. Обязательно ещё нужен отдельный класс контекст, который расширен от интерфейса стратегии, который хранит и исполняет стратегию

## Builder - Строитель

Builder - паттерн(пораждающий) позволяющий избежать создания миллиарда конструкторов для миллиона параметров. Он позволяет создать объект и удобненько задать ему параметры.

Пример:

```java
public class Person {

    private String name;
    private String surname;
    private int age;
    private int height;
    private int weight;
    private Set parents;

    public static class Builder {
        private Person newPerson;

        public Builder() {
            newPerson = new Person();
        }

        public Builder withName(String name){
         newPerson.name = name;
            return this;
        }

        public Builder withSurname(String surname){
            newPerson.surname = surname;
            return this;
        }

        public Builder withAge(int age){
            newPerson.age = age;
            return this;
        }

        public Builder withHeight(int height){
            newPerson.height = height;
            return this;
        }

        public Builder withWeight(int weight){
            newPerson.weight = weight;
            return this;
        }

        public Builder withParents(Set parents){
            newPerson.parents = parents;
            return this;
        }

        public Person build(){
            return newPerson;
        }

    }
}
```

## Fabric - Фабрика

Fabric - паттерн(пораждающий), указываешь экземпляр какого класса ты хочешь получить(например, в enum указываешь какие варианты вообще есть) и фабрика тебе инициализирует объект этого класса и возвращает. Есть так же вариант, что у класса много полей и фабрика просто возвращает объект с нужными инициализациями

## Chain of responsibility - Цепочка обязанностей

Chain of responsibility - паттерн(поведенческий) вместо лапши из кода с кучей проверок, позволяет создать легко редактируеммый набор проверок. Каждая проверка, это объект, реализующий ровно одну проверку и наследующийся от интерфейса с одним методом. В идеале проверка принимает какой-то объект. Этот объект имеет ссылку на следующую проверку и запускает ее если результат удовлетворительный или возвращает false. Так же цепочка собирается из массива, через класс, который видимо исторически, называется Middleware

## Template Method - Шаблонный метод

Template Method - паттерн(поведенческий) если у вас есть набор алгоритмов со схожей концепцией но с разной реализацией конкретных шагов реализации, то этот паттерн ваш друг

Пример: мы пишем поведение для НПС в RTS. У нас есть люди, орки и нейтралы. Мы создаём шаблонный класс, в котором есть методы типа, строить, атаковать, собирать ресурсы. Эти методы могут быть пустыми, а могут реализовывать конкретную базовую логику. А также есть шаблонный метод который вызывает их в определенном порядке. Дальше для каждой рассы создаём класс, унаследованный от шаблонного класса и переопределяем те методы, которые нужно переопределить

## Facade - Фасад

Facade - паттерн(структурный) обычно фасад так же является и Singleton. Если у вас набор сложных зависимостей или какая-то огромная библиотека, но вам нужна только часть всего этого функционала или спрятать сложные зависимости, то использование фасада - ваш выбор. У фасада может быть абсолютно другой интерфейс, сильно урезанные возможности в отличие от Фасадируемой библиотеки/кода. Все взаимосвязи объектов прячутся внутри фасада, а пользователь просто удобненько им пользуется

## Decorator - Декоратор

Decorator - паттерн(структурный) "оборачиваем" один класс другим

Пример: если надо отправлять сообщение в Facebook, Telegram, VK и по SMS. При этом иногда вам надо только один способ, иногда все, а иногда все кроме одного и т.д. Для каждого такого действия создаётся по классу (естественно они все от одного интерфейса). И дальше, по мере необходимости оборачиваем один класс другим:

```
stack = new Notifier("It is message")
if(isFacebook) { stack = new FacebookDecorator(stack); }
if(isTelegram) { stack = new TelegramDecorator(stack); }
if(isVK) { stack = new VkDecorator(stack); }
if(isSMS) { stack = new SmsDecorator(stack); }
stack.doSomething();
```

## Proxy - Заместитель

Proxy - паттерн(структурный) выглядит как Facade или Decorator, но в отличии от них предоставляет тот же интерфейс

Пример: есть база данных. Запросы к ней ресурсоемки в обработке. Можно сделать объект дублирующий интерфейс базы данных, но способный логировать запросы или собирающий несколько запросов в один или обладающий кэшэм...
