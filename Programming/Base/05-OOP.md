# ООП

# Принципы ООП

## Абстракция

Абстракция - это способ выделить набор полей и методов, единых для всех объектов в отдельную сущность

-   class - абстракция для объекта
-   class - может быть абстракцией для другого класса

## Инкапсуляция

Инкапсуляция - объединение в одном месте данных и методов:

-   класс является капсулой, в которую кладутся и методы и свойства
-   это кажется очевидным, но из контекста процедурного программирования, это не так

## Сокрытие

Сокрытие - относится к инкапсуляции. Позволяет скрывать поля и методы объекта от других

-   скрывает методы и поля от пользователя, потому что эти методы и поля внутренние и нужны для функционирования класса

## Наследование

Наследование - это концепция, согласно которой одни классы, называемые родительскими, могут лежать в основе других классов, называемых дочерними:

-   родитель - более общий Class
-   потомок - более специфичный

## Полиморфизм

Полиморфизм - (принимающий много форм)способность объекта использовать методы родительского класса, даже если родителя не существует

-   есть полиморфизм методов. Когда можно выполнить перегрузку метода, но это не "правильный" полиморфизм

Разновидности полиморфизма:

-   Ad-hoc-полиморфизм
    -   в строго типизированных - перегрузка методов
    -   в слабо типизированных - через приведение типов
-   Параметрический(динамический) полиморфизм
    -   обрабатывать разные типы данных одинаковым кодом

# SOLID

## Single Responsibility(SRP)

Single Responsibility(SRP) - один класс, одна задача

-   то есть, никаких огромных многозадачных классов

## Open Closed(OCP)

Open Closed(OCP) - программные сущности должны быть открыты для расширения, но закрыты для изменения

-   то есть мы добавляем новую сущность, по средствам композиции, наследования...

## Liskow Substitution(LSP)

Liskow Substitution(LSP) - сущности использующие родительский тип, должны так же работать и с наследниками

## Interface Segregation (ISP)

Interface Segregation (ISP) - программные сущности не должны зависить от методов которые они НЕ используют

## Dependency Inversion(DIP)

Dependency Inversion(DIP) - модули высокого уровня не должны зависить от модулей более низкого уровня

-   объекты должны взаимодействовать через интерфейсы и не думать как работают объекты к которым они обращаются внутри
-   короче, больше декораторов

# Паттерны

Паттерны организующие структуры данных:

-   [EAV - структура БД, для создания объектов внутри нее](#entity-attribute-valueeav)
-   [CSQ - ](#csq)
-   [CSQR - ](#csqr)

Паттерны оберточные/проксиподобные:

-   [Adapter](#adapter---адаптер)
-   [Facade](#facade---фасад)
-   [Decorator](#decorator---декоратор)
-   [Proxy](#proxy---заместитель)

Паттерны генератороподобные/билдероподобные:

-   [Abstract Factory](#abstract-factory---абстрактная-фабрика)
-   [Builder](#builder---строитель)
-   [Fabric](#fabric---фабрика)
-   [Prototype](#prototype---прототип)

Паттерны работающие с поведением:

-   [State](#state---состояние)
-   [Strategy](#strategy---стратегия)
-   [Chain of responsibility](#chain-of-responsibility---цепочка-обязанностей)
-   [Template Method](#template-method---шаблонный-метод)

Паттерны прокидывающие логику:

-   [Command](#command---команда)
-   [Bridge](#bridge---мост)
-   [Observer](#observer---наблюдатель)
-   [Mediator](#mediator---посредник)

Многопоточные паттерны:

-   [Active object](#active-object---активный-объект)
-   [Lock](#lock---блокировка)
-   [Monitor](#monitor---монитор)
-   [Double check locking]()
-   [Scheduler]()

Паттерны в основе которых деревья:

-   [Iterator](#iterator---итератор)
-   [Composite](#composite---компоновщик)
-   [Visitor](#visitor---посетитель)

Языковые паттерны:

-   [Interpretator](#interpretator---интерпретатор)

Паттерны(остальные):

-   [Singleton](#singleton---одиночка)
-   [Flyweight](#flyweight---приспособленецлегковес)
-   [Memento](#memento---снимокхранитель)

# Примеры

## Active Object - Активный объект

Активный объект - мы работаем с приложение как обычно, и когда нужен асинхронный/многопоточный запрос, у нас есть объект future. Мы вызываем нужный нам метод, он возвращает fututre, в котором пока нет данных, но они потом появятся. В это время основная программа просто исполняется дальше

## Lock - Блокировка

Lock - захватываем mutex объекта, и не позволяем с ним работать из других потоков

## Monitor - Монитор

Monitor - реализация паттерна это synchronized в java. Когда данным спрятаны в объекте, а доступ к ним воможен только через один метод. А этот метод... Может выполняться только в одном потоке

## Double checked locking - Блокировка с двойно проверкой

Double checked locking - например, есть синглтон. При его вызове мы проверяем, null ли наш синглтон. Если null, то мы блочим мьютекс, и проверяем еще раз синглтон на null. После инициализируем объект

```java
public static getSinglton() {
    if (instance == null) {
        synchronized (Singleton.class) {
            if (instance == null) {
                instance = new Singlton()
            }
        }
    }
}
```

## Sheduler - Планировщик

Sheduler - в общем есть объект sheduler, и объекты события, которые он проверяет. Если поток свободен и событие готово исполниться, он лочит событие для других потоков и запускает его. Запущенный объект сам разлочит себя, и при следущей проходке sheduler увидет что он освободился. И все начнется заново

## Entity-Attribute-Value(EAV)

Шаблон для БД ориентированных систем. Суть в том, что есть табличка для:

-   Entity(сущностей)

| ID  | Name    |
| :-- | :------ |
| 1   | SSD     |
| 2   | HDD     |
| 3   | SSD/HDD |

-   Attribute(аттрибуты)

| ID  | Entity | Name  | IsNum |
| :-- | :----- | :---- | :---- |
| 1   | 2      | Size  | 1     |
| 2   | 1      | Size  | 1     |
| 3   | 1      | Color | 0     |

-   Value(значения) - задает Value, связывает Attribute и Entity

| Instance_ID | Entity_ID | Attribute_ID | Text_value | Num_value |
| :---------- | :-------- | :----------- | :--------- | :-------- |
| 1           | 2         | 2            |            | 300       |
| 2           | 1         | 1            |            | 0         |
| 1           | 2         | 2            |            | 100       |
| 3           | 1         | 3            | red        |           |
| 3           | 1         | 3            | green      |           |

## CSQ

CSQ - разделяет запись и чтение для БД по двум разным группам методов

-   commands(комнады) - изменяют состояние системы, но не возвращают данных(по сути запись)
-   queries(запросы) - возвращают результат и не меняют наблюдаемое состояние системы(по сути чтение)

Для чего это надо:

-   мы разделяем на чистые и грязные методы
-   это основа для масштабирования системы на несколько машин
-   удобно параллелить

## CSQR

CSQR - онсован на CSQ, разделяет запись и чтение для БД по двум разным группам объектов

-   commands(комнады) - изменяют состояние системы, но не возвращают данных(по сути запись)
-   queries(запросы) - возвращают результат и не меняют наблюдаемое состояние системы(по сути чтение)

Структура реализованная для commands/queries следующая:

-   Command/Query
    -   фиговина которая просто хранит инфу, которую потом прокинут в Handler
    -   по типу Command/Query, определяют какой Handler вызвать
-   Handler
    -   на уровне типов получает то, к какой команде относится
    -   обладает execute, который и вызывается через Dispatcher
-   Dispatcher
    -   по переданной Command/Query вернет Handler
    -   используя абсолютную магиию(например Spring), находит все Handler

## Adapter - Адаптер

Adapter - паттерн(структурный) прослойка которая адаптирует выходные данные из первого Object во входные данные во второй Object

## Facade - Фасад

Facade - паттерн(структурный) обычно фасад так же является и Singleton. Если у вас набор сложных зависимостей или какая-то огромная библиотека, но вам нужна только часть всего этого функционала или спрятать сложные зависимости, то использование фасада - ваш выбор. У фасада может быть абсолютно другой интерфейс, сильно урезанные возможности в отличие от Фасадируемой библиотеки/кода. Все взаимосвязи объектов прячутся внутри фасада, а пользователь просто удобненько им пользуется

## Decorator - Декоратор

Decorator - паттерн(структурный) "оборачиваем" один класс другим

Пример: если надо отправлять сообщение в Facebook, Telegram, VK и по SMS. При этом иногда вам надо только один способ, иногда все, а иногда все кроме одного и т.д. Для каждого такого действия создаётся по классу (естественно они все от одного интерфейса). И дальше, по мере необходимости оборачиваем один класс другим:

```
stack = new Notifier("It is message")
if(isFacebook) { stack = new FacebookDecorator(stack); }
if(isTelegram) { stack = new TelegramDecorator(stack); }
if(isVK) { stack = new VkDecorator(stack); }
if(isSMS) { stack = new SmsDecorator(stack); }
stack.doSomething();
```

## Proxy - Заместитель

Proxy - паттерн(структурный) выглядит как Facade или Decorator, но в отличии от них предоставляет тот же интерфейс

Пример: есть база данных. Запросы к ней ресурсоемки в обработке. Можно сделать объект дублирующий интерфейс базы данных, но способный логировать запросы или собирающий несколько запросов в один или обладающий кэшэм...

## Abstract factory - Абстрактная фабрика

Abstract factory - паттерн(пораждающий). Используется когда надо создавать сильно похожие объекты, но реализованные по разному

Пример: у нас фабрика для btn(win), btn(mac), checkbox(win) и checkbox(mac). Мы создаем Abstract factory, которая при инициализации будет определять, на win или mac мы находимся и вызывать нужную фабрику

## Builder - Строитель

Builder - паттерн(пораждающий) позволяющий избежать создания миллиарда конструкторов для миллиона параметров. Он позволяет создать объект и удобненько задать ему параметры.

Пример:

```java
public class Person {

    private String name;
    private String surname;
    private int age;
    private int height;
    private int weight;
    private Set parents;

    public static class Builder {
        private Person newPerson;

        public Builder() {
            newPerson = new Person();
        }

        public Builder withName(String name){
         newPerson.name = name;
            return this;
        }

        public Builder withSurname(String surname){
            newPerson.surname = surname;
            return this;
        }

        public Builder withAge(int age){
            newPerson.age = age;
            return this;
        }

        public Builder withHeight(int height){
            newPerson.height = height;
            return this;
        }

        public Builder withWeight(int weight){
            newPerson.weight = weight;
            return this;
        }

        public Builder withParents(Set parents){
            newPerson.parents = parents;
            return this;
        }

        public Person build(){
            return newPerson;
        }

    }
}
```

## Fabric - Фабрика

Fabric - паттерн(пораждающий), указываешь экземпляр какого класса ты хочешь получить(например, в enum указываешь какие варианты вообще есть) и фабрика тебе инициализирует объект этого класса и возвращает. Есть так же вариант, что у класса много полей и фабрика просто возвращает объект с нужными инициализациями

## Prototype - Прототип

Prototype - паттерн(пораждающий), который позволяет создавать копию объекта. Это может помочь ускорить код (если поля нового объекта долго вычисляются) или упростить инициализацию (создаёшь копию и уже в ней меняешь нужные поля). Вся суть в методе (интерфейса с описанным методом) copy. Который вызывается если надо скопировать объект

## State - Состояние

State - паттерн(поведенческий)

Пример: есть аудиоплеер и у него три состояния: заблокирован, разблокирован, музыка играет. Для этих состояний создаётся общий интерфейс. Для каждого состояния создаётся класс расширенный этим интерфейсом. Определяется контекст(место где хранятся и вызываются состояния). Дальше мы уже переключаем состояния либо внутри созданных классов либо вне их

## Strategy - Стратегия

Strategy - паттерн(поведенческий)

Пример: есть навигатор и он может прокладывать путь от точки А к точке Б несколькими способами. Каждый такой способ заносим в отдельный класс, но естественно с одинаковыми интерфейсами. Обязательно ещё нужен отдельный класс контекст, который расширен от интерфейса стратегии, который хранит и исполняет стратегию

## Chain of responsibility - Цепочка обязанностей

Chain of responsibility - паттерн(поведенческий) вместо лапши из кода с кучей проверок, позволяет создать легко редактируеммый набор проверок. Каждая проверка, это объект, реализующий ровно одну проверку и наследующийся от интерфейса с одним методом. В идеале проверка принимает какой-то объект. Этот объект имеет ссылку на следующую проверку и запускает ее если результат удовлетворительный или возвращает false. Так же цепочка собирается из массива, через класс, который видимо исторически, называется Middleware

## Template Method - Шаблонный метод

Template Method - паттерн(поведенческий) если у вас есть набор алгоритмов со схожей концепцией, но с разной реализацией конкретных шагов реализации, то этот паттерн ваш друг

Пример: мы пишем поведение для НПС в RTS. У нас есть люди, орки и нейтралы. Мы создаём шаблонный класс, в котором есть методы типа, строить, атаковать, собирать ресурсы. Эти методы могут быть пустыми, а могут реализовывать конкретную базовую логику. А также есть шаблонный метод который вызывает их в определенном порядке. Дальше для каждой рассы создаём класс, унаследованный от шаблонного класса и переопределяем те методы, которые нужно переопределить

## Iterator - Итератор

Iterator - паттерн(поведенческий) который позволяет иттерироваться нестандартными способами по сложным структурам

Пример: сейчас достаточно обходить дерево в глубину, но потом потребуется возможность перемещаться по дереву в ширину. А на следующей неделе и того хуже — понадобится обход коллекции в случайном порядке. Решение: создай интерфейс для итератора (там как минимум должна быть функция получения элемента), для каждого способа иттерирования создавай свой класс расширенный от итератора. Каждый класс в конструкторе принимает, коллекцию по которой будет иттерироваться. Ну а дальше, иттерируйся как душа скажет

## Command - Команда

Command - паттерн(поведенческий) шаблон отвечающий за события. Так же связующий между интерфейсом и логикой. Бонусом идёт возможность логирования, а также ведение истории вызванных комманд

Пример: мы сдаём интерфейс Command, где в идеале, (не в идеале undo, backup и что захочешь) определен один метод - execute. В реализации интерфейса описываем что делает execute и радуемся жизни. Вопрос только с данными, execute получает данные из родительского класса

## Composite - Компоновщик

Composite - паттерн(структурный) Это просто дерево. Единственное ограничение паттерна, что контейнер где хранятся элементы и сам элемент должны наследовать один класс(или интерфейс). Это связано с тем, что пользователь не должен видеть разницы между контейнером и элементом. В общем у контейнера в отличии от элемента должно быть пару методов типа добавить, удалить и т.д.

## Interpretator - Интерпретатор

Interpretator - паттерн(поведенческий) является реализацией языка с бинарными(это не точно) операторами. Паттерн схож с компановщик, разделен на три класса:

-   контекст - дерево операторов
-   нетерминальное выражение - операция/действие(по факту узел дерева). Унаследован от класса выражения
-   терминальное выражение - символ/значение(по факту лист дерева). Унаследован от класса выражения

## Bridge - Мост

Bridge - паттерн(структурный паттерн) в котором есть две отдельные иерархии - абстракция(например GUI) и реализация(например Logic). Теперь мы можем прокинуть абстракцию в объекты классов реализации и вызывать нужные нам методы и поля.

Пример: в вебе абстракция = тема. А реализация = условный реакт-код. После такого, мы не только можем отдельно редактировать стили от логики, но и в runtime менять темы. Так же прикол в том что логик может быть много и наследуясь от реализации все классы будут иметь доступ к абстракции

## Observer - Наблюдатель

Observer - паттерн(поведенческий) создаётся объект с тремя базывами функциями и Map:

-   Map - хранит данные где: key - имя события, value - массив объектов подписанных на события
-   Subscribe - функция подиски объектом на событие
-   Unsubscribe - отписка от события
-   Send - функция которая сообщает всем subscribers что событие произошло и вызывает у всех subscribers объектов некоторую функцию(едина для всех объектов), которая принимает имя события

## Singleton - Одиночка

Singleton - паттерн(пораждающий) к этому паттерну только одно требование, чтобы объект класса можно было создать только один раз, так что если объект нужно создавать только один раз, то тебе к этому паттерну

## Visitor - Посетитель

Visitor - паттерн(поведенческий) обходит дерево

Пример: есть дерево из объектов разных классов. Его надо обойти и создать xml. Менять поведение внутри самих этих классов - некамильфо, так ещё и может сделать классы нестабильными. Поэтому создаём новый класс, visitor. В нем, для каждого класса присутствующего в дереве, создаём метод, принимающий именно этот класс из дерева. В самих классах дерево добавляем метод accept принимающий visitor (visitor может быть несколько, например надо ещё и в pdf экспортировать), а уже этот метод вызывает в visitor нужный метод принимающий this класс

## Mediator - Посредник

Mediator - паттерн(поведенческий) контроллирующий поведение между несколькими объектами

Пример: у нас есть много объектов со сложными связями. Это неудобно. Поэтому создаем посредника и пусть объекты отправляют в него данные, а он уже решает что с ними делать! Все объекты должны иметь ссылку на посредника, посредник должен иметь ссылки на все объекты

## Flyweight - Приспособленец/Легковес

Flyweight - паттерн(структурный) если много однотипных объектов, то можно применить Легковес. Статичные данные, которые не меняются (например текстуры одинаковых НПС) выносятся в отдельный объект, и на них хранятся только ссылки. А нестатичные данные (типо координат) остаются в самом объекте. И ещё, обязательно нужна фабрика для статичных объектов, чтобы знать, когда создать новый, а когда вернут ссылку

## Memento - Снимок/Хранитель

Memento - паттерн, который хранит состояние объекта и может его восстанавливать. Из минусов жрет очень много памяти.

Пример: в объекте снимки которого хотим сделать, создаём метод backup и restore. Backup упаковывает поля объекта(например в byteArray), а restore из объекта backup - восстанавливает поля. Также создаётся класс memento, который хранит в себе ссылку на объект и его снимок, а также может восстановить состояние. А дальше дело с этим что хочешь
