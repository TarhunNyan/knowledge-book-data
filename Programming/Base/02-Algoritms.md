# Алгоритмы и паттерны

# Алгоритмы

## Big O

Big O нотация - показывает асимптоматику(характер функции $n -> const$) числа операций от числа элементов в общем виде:

| Название                     | Big O нотация | Пример                            |
| :--------------------------- | :------------ | :-------------------------------- |
| Константа                    | $O(1)$        | Взять 20-ый элемент массива       |
| Сложность порядка n          | $O(n)$        | Пройтись в цикле по всему массиву |
| Сложность порядка n квадрат  | $O(n^2)$      | Цикл в цикле                      |
| Сложность порядка логарифм n | $O(log{n})$   | Binary search                     |

## Binary Search

Binary Search - берём элемент из середины массива и сравниваем с ключом. Ключ меньше => повторяем с левой частью массива. Ключ больше => повторяем с правой частью массива:

-   Есть отсортированный массив чисел
-   Есть ключ, позицию котороно ищем в массиве

# Деревья

Деревья - одна из о наиболее распространенных структур данных в информатике, эмулирующая древовидную структуру в виде набора связанных узлов

## Бинарное дерево

Бинарное дерево - дерево в котором каждый узел имеет не более 2-ух потомков

Сортированное бинарное дерево:

-   каждый узел также является сортированным бинарным деревом
-   все значения узлов слева не больше, а значения справа не меньше, чем значение корня

## Красно-черное дерево

Красно-черное дерево:

-   сортированное бинарное дерево
-   имеет дополнительным бит информации(красный/черный узел)
-   дерево - самобалансирущееся. То есть число операций: $O(log{n})$

Правила для самобалансировки:

-   Корень(не поддеревья) - всегда черный
-   Конечные узлы - черные
-   Дочерние узлы от красного узла - черные
-   Глубина(если мы считаем только черные узлы) - везде одинакова

## B-деревья

B-дерево

НЕ бинарное, а обычное дерево. Является всегда жестко сбалансированными. В узлах храняться ссылки на следующие узлы, а между ними значения. Значения слева и справа от ссылки задают range, в пределах которого должен находиться потомок указанный в ссылке. Значений должно быть меньше заданного  Mathjax (уровень дерева). Если за k обозначить число значений в некотором узле, то у него либо 0 либо k+1(по числу ссылок) потомков

В общем, B-дерево долго добавляет элемент, зато в нем быстрые переходы от одного узла к другому. Например B-дерево используется в файловой системе

# Паттерны

## Entity-Attribute-Value(EAV)

Шаблон для ДБ ориентированных систем. Суть в том, что есть табличка для:

-   Entity(сущностей)

| ID  | Name    |
| :-- | :------ |
| 1   | SSD     |
| 2   | HDD     |
| 3   | SSD/HDD |

-   Attribute(аттрибуты)

| ID  | Entity | Name  | IsNum |
| :-- | :----- | :---- | :---- |
| 1   | 2      | Size  | 1     |
| 2   | 1      | Size  | 1     |
| 3   | 1      | Color | 0     |

-   Value(значения) - задает Value, связывает Attribute и Entity

| Instance_ID | Entity_ID | Attribute_ID | Text_value | Num_vaue |
| :---------- | :-------- | :----------- | :--------- | :------- |
| 1           | 2         | 2            |            | 300      |
| 2           | 1         | 1            |            | 0        |
| 1           | 2         | 2            |            | 100      |
| 3           | 1         | 3            | red        |          |
| 3           | 1         | 3            | green      |          |

## Abstract factory - Абстрактная фабрика

Abstract factory - паттерн(пораждающий). Используется когда надо создавать сильно похожие объекты, но реализованные по разному

Пример: у нас фабрика для btn(win), btn(mac), checkbox(win) и checkbox(mac). Мы создаем Abstract factory, которая при инициализации будет определять, на win или mac мы находимся и вызывать нужную фабрику

## Adapter - Адаптер

Adapter - паттерн(структурный) прослойка которая адаптирует выходные данные из первого Object во входные данные во второй Object

## Iterator - Итератор

Iterator - паттерн(поведенческий) который позволяет иттерироваться нестандартными способами по сложным структурам

Пример: сейчас достаточно обходить дерево в глубину, но потом потребуется возможность перемещаться по дереву в ширину. А на следующей неделе и того хуже — понадобится обход коллекции в случайном порядке. Решение: создай интерфейс для итератора (там как минимум должна быть функция получения элемента), для каждого способа иттерирования создавай свой класс расширенный от итератора. Каждый класс в конструкторе принимает, коллекцию по которой будет иттерироваться. Ну а дальше, иттерируйся как душа скажет

## Command - Команда

Command - паттерн(поведенческий) шаблон отвечающий за события. Так же связующий между интерфейсом и логикой. Бонусом идёт возможность логирования, а также ведение истории вызванных комманд

Пример: мы сдаём интерфейс Command, где в идеале, (не в идеале undo, backup и что захочешь) определен один метод - execute. В реализации интерфейса описываем что делает execute и радуемся жизни. Вопрос только с данными, execute получает данные из родительского класса

## Composite - Компоновщик

Composite - паттерн(структурный) Это просто дерево. Единственное ограничение паттерна, что контейнер где хранятся элементы и сам элемент должны наследовать один класс(или интерфейс). Это связано с тем, что пользователь не должен видеть разницы между контейнером и элементом. В общем у контейнера в отличии от элемента должно быть пару методов типа добавить, удалить и т.д.

## Interpretator - Интерпретатор

Interpretator - паттерн(поведенческий) является реализацией языка с бинарными(это не точно) операторами. Паттерн схож с компановщик, разделен на три класса:

-   контекст - дерево операторов
-   нетерминальное выражение - операция/действие(по факту узел дерева). Унаследован от класса выражения
-   терминальное выражение - символ/значение(по факту лист дерева). Унаследован от класса выражения

## Bridge - Мост

Bridge - паттерн(структурный паттерн) в котором есть две отдельные иерархии - абстракция(например GUI) и реализация(например Logic). Теперь мы можем прокинуть абстракцию в объекты классов реализации и вызывать нужные нам методы и поля.

Пример: в вебе абстракция = тема. А реализация = условный реакт-код. После такого, мы не только можем отдельно редактировать стили от логики, но и в runtime менять темы. Так же прикол в том что логик может быть много и наследуясь от реализации все классы будут иметь доступ к абстракции

## Observer - Наблюдатель

Observer - паттерн(поведенческий) создаётся объект с тремя базывами функциями и Map:

-   Map - хранит данные где: key - имя события, value - массив объектов подписанных на события
-   Subscribe - функция подиски объектом на событие
-   Unsubscribe - отписка от события
-   Send - функция которая сообщает всем subscribers что событие произошло и вызывает у всех subscribers объектов некоторую функцию(едина для всех объектов), которая принимает имя события

## Singleton - Одиночка

Singleton - паттерн(пораждающий) к этому паттерну только одно требование, чтобы объект класса можно было создать только один раз, так что если объект нужно создавать только один раз, то тебе к этому паттерну

## Visitor - Посетитель

Visitor - паттерн(поведенческий) обходит дерево

Пример: есть дерево из объектов разных классов. Его надо обойти и создать xml. Менять поведение внутри самих этих классов - некамильфо, так ещё и может сделать классы нестабильными. Поэтому создаём новый класс, visitor. В нем, для каждого класса присутствующего в дереве, создаём метод, принимающий именно этот класс из дерева. В самих классах дерево добавляем метод accept принимающий visitor (visitor может быть несколько, например надо ещё и в pdf экспортировать), а уже этот метод вызывает в visitor нужный метод принимающий this класс

## Mediator - Посредник

Mediator - паттерн(поведенческий) контроллирующий поведение между несколькими объектами

Пример: у нас есть много объектов со сложными связями. Это неудобно. Поэтому создаем посредника и пусть объекты отправляют в него данные, а он уже решает что с ними делать! Все объекты должны иметь ссылку на посредника, посредник должен иметь ссылки на все объекты

## Flyweight - Приспособленец/Легковес

Flyweight - паттерн(структурный) если много однотипных объектов, то можно применить Легковес. Статичные данные, которые не меняются (например текстуры одинаковых НПС) выносятся в отдельный объект, и на них хранятся только ссылки. А нестатичные данные (типо координат) остаются в самом объекте. И ещё, обязательно нужна фабрика для статичных объектов, чтобы знать, когда создать новый, а когда вернут ссылку

## Prototype - Прототип

Prototype - паттерн(пораждающий), который позволяет создавать копию объекта. Это может помочь ускорить код (если поля нового объекта долго вычисляются) или упростить инициализацию (создаёшь копию и уже в ней меняешь нужные поля). Вся суть в методе (интерфейса с описанным методом) copy. Который вызывается если надо скопировать объект

## Memento - Снимок/Хранитель

Memento - паттерн, который хранит состояние объекта и может его восстанавливать. Из минусов жрет очень много памяти.

Пример: в объекте снимки которого хотим сделать, создаём метод backup и restore. Backup упаковывает поля объекта(например в byteArray), а restore из объекта backup - восстанавливает поля. Также создаётся класс memento, который хранит в себе ссылку на объект и его снимок, а также может восстановить состояние. А дальше дело с этим что хочешь

## State - Состояние

State - паттерн(поведенческий)

Пример: есть аудиоплеер и у него три состояния: заблокирован, разблокирован, музыка играет. Для этих состояний создаётся общий интерфейс. Для каждого состояния создаётся класс расширенный этим интерфейсом. Определяется контекст(место где хранятся и вызываются состояния). Дальше мы уже переключаем состояния либо внутри созданных классов либо вне их

## Strategy - Стратегия

Strategy - паттерн(поведенческий)

Пример: есть навигатор и он может прокладывать путь от точки А к точке Б несколькими способами. Каждый такой способ заносим в отдельный класс, но естественно с одинаковыми интерфейсами. Обязательно ещё нужен отдельный класс контекст, который расширен от интерфейса стратегии, который хранит и исполняет стратегию

## Builder - Строитель

Builder - паттерн(пораждающий) позволяющий избежать создания миллиарда конструкторов для миллиона параметров. Он позволяет создать объект и удобненько задать ему параметры.

Пример:

```java
public class Person {

    private String name;
    private String surname;
    private int age;
    private int height;
    private int weight;
    private Set parents;

    public static class Builder {
        private Person newPerson;

        public Builder() {
            newPerson = new Person();
        }

        public Builder withName(String name){
         newPerson.name = name;
            return this;
        }

        public Builder withSurname(String surname){
            newPerson.surname = surname;
            return this;
        }

        public Builder withAge(int age){
            newPerson.age = age;
            return this;
        }

        public Builder withHeight(int height){
            newPerson.height = height;
            return this;
        }

        public Builder withWeight(int weight){
            newPerson.weight = weight;
            return this;
        }

        public Builder withParents(Set parents){
            newPerson.parents = parents;
            return this;
        }

        public Person build(){
            return newPerson;
        }

    }
}
```

## Fabric - Фабрика

Fabric - паттерн(пораждающий), указываешь экземпляр какого класса ты хочешь получить(например, в enum указываешь какие варианты вообще есть) и фабрика тебе инициализирует объект этого класса и возвращает. Есть так же вариант, что у класса много полей и фабрика просто возвращает объект с нужными инициализациями

## Chain of responsibility - Цепочка обязанностей

Chain of responsibility - паттерн(поведенческий) вместо лапши из кода с кучей проверок, позволяет создать легко редактируеммый набор проверок. Каждая проверка, это объект, реализующий ровно одну проверку и наследующийся от интерфейса с одним методом. В идеале проверка принимает какой-то объект. Этот объект имеет ссылку на следующую проверку и запускает ее если результат удовлетворительный или возвращает false. Так же цепочка собирается из массива, через класс, который видимо исторически, называется Middleware

## Template Method - Шаблонный метод

Template Method - паттерн(поведенческий) если у вас есть набор алгоритмов со схожей концепцией но с разной реализацией конкретных шагов реализации, то этот паттерн ваш друг

Пример: мы пишем поведение для НПС в RTS. У нас есть люди, орки и нейтралы. Мы создаём шаблонный класс, в котором есть методы типа, строить, атаковать, собирать ресурсы. Эти методы могут быть пустыми, а могут реализовывать конкретную базовую логику. А также есть шаблонный метод который вызывает их в определенном порядке. Дальше для каждой рассы создаём класс, унаследованный от шаблонного класса и переопределяем те методы, которые нужно переопределить

## Facade - Фасад

Facade - паттерн(структурный) обычно фасад так же является и Singleton. Если у вас набор сложных зависимостей или какая-то огромная библиотека, но вам нужна только часть всего этого функционала или спрятать сложные зависимости, то использование фасада - ваш выбор. У фасада может быть абсолютно другой интерфейс, сильно урезанные возможности в отличие от Фасадируемой библиотеки/кода. Все взаимосвязи объектов прячутся внутри фасада, а пользователь просто удобненько им пользуется

## Decorator - Декоратор

Decorator - паттерн(структурный) "оборачиваем" один класс другим

Пример: если надо отправлять сообщение в Facebook, Telegram, VK и по SMS. При этом иногда вам надо только один способ, иногда все, а иногда все кроме одного и т.д. Для каждого такого действия создаётся по классу (естественно они все от одного интерфейса). И дальше, по мере необходимости оборачиваем один класс другим:

```
stack = new Notifier("It is message")
if(isFacebook) { stack = new FacebookDecorator(stack); }
if(isTelegram) { stack = new TelegramDecorator(stack); }
if(isVK) { stack = new VkDecorator(stack); }
if(isSMS) { stack = new SmsDecorator(stack); }
stack.doSomething();
```

## Proxy - Заместитель

Proxy - паттерн(структурный) выглядит как Facade или Decorator, но в отличии от них предоставляет тот же интерфейс

Пример: есть база данных. Запросы к ней ресурсоемки в обработке. Можно сделать объект дублирующий интерфейс базы данных, но способный логировать запросы или собирающий несколько запросов в один или обладающий кэшэм...
