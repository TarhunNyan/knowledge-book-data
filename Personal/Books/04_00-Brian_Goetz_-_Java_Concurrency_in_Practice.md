# Брайн Гетц - Java Concurrency на практике

Книга старенькая, 2006 года. Но вроде как классика, написанная людьми занимавшимися проектированием механизмов многопоточности в Java

# Глава 1 - Введение

Вводная вода:

-   до 1.2.2 идет лирике о том насколько потоки полезны и круты
-   1.2.2 - Простота моделирования
    -   Сервлеты
        -   асинхронную работу, разбиваем на несколько синхронных потоков данных
        -   Эти данные попадают в отдельные потоки
        -   Потоки взаимодействуют друг с другом только в отдельных точках синхронизации
-   1.2.3 - Упрощенная обработка асинхронных событий
    -   Речь о том, что раньше было ограничение на число потоков на уровне опперационных систем. Поэтому приходилось развивать асинхронные методы чтения/записи
    -   В Java есть библиотека(java.nio), которая позволяет обойти ограничение на число потоков
        -   Библиотека была настолько крута, что в Linux ввели копию этого механизма
-   1.2.4 - Более отзывчивые пользовательские интерфейсы
    -   В общем, раньше все было в одном потоке. И GUI и логика, что было плохо. Теперь GUI работает в отдельном потоке, и вызывает обработчики

Наконец чутка практики:

-   1.3.1 - Угрозы безопасности
    -   Простенький пример, показывающий что есть потоконебезопасный код
    -   Вводятся специальные аннотации
        -   @NotThreadSafe - не потокобезопасный класс(если у класса нет @ThreadSafe, то по определению класс не потокобезопасный)
        -   @ThreadSafe - потокобезопасный класс
        -   @Immutable - класс является неммутируемым(данные внутри неизменяемы). Следовательно потокобезопасным
-   1.3.2 - Сбои жизнеспособности
    -   Безопасность(safety) - подразумевает отсутствие плохих состояний
    -   Жизнеспособность(liveness) - преодоление плохих состояний с хорошим исходом
    -   Упоминаются
        -   Deadlock(взаимная блокировка)
        -   Starvation(голодание)
        -   Livelock(активную блокировку)
-   1.4 - Потоки везде
    -   Тут нас пугают, что потоки не опциональная возможность, а обязательное знание
    -   Всякие сборщики мусора, Swing, Timer, AWT - создают потоки, а значит классы должны быть потокобезопасными(лол)
    -   Идут пояснение, почему многопоточность, как зараза. И что во многих местах требуется @ThreadSafe

# Глава 2 - Потокобезопасность

-   2.1 - Потокобезопасность
    -   Дается определение thread-safety(потокобезопасносный класс)
        -   Если класс ведет себя правильно во время доступа из многочисленных потоков и не требует координации со стороны вызывающего кода
-   2.1.1 - Пример сервлетов без поддержки внутреннего состояния
-   2.2 - Атомарность
    -   Тут приводится пояснение, что такое атомарность. И что не атомарные операция - не потокобезопасны, потому что может поменяться состояние
-   2.2.1 - Состояние гонки
    -   Пример с описанием того, что имеется ввиду под состоянием гонки
    -   Пример описывает ситуацию встречи с другом в точке А или Б
-   2.2.2 - Пример: состояние гонки в ленивой инициализации
    -   Короче, классический синглтон, оказался не потокобезопасным
-   2.2.3 - Составные действия
    -   Составные действия
        -   check-then-act(проверить потом действовтать)
        -   read-modify-write(прочитать изменить записать)
    -   Составные действия - являются источником проблем для потокобезопасности
    -   Составные действия - должны быть атомарными
    -   Приводится пример, для создание потокобезопасного счетчика
        -   java.util.concurrent.atomic - пакет в котором валяются атомарные, потокобезопасные операции
        -   AtomicLomg - класс из пакета java.util.concurrent.atomic, который использовался в примере
    -   Вывод, используйте потокобезопасные классы, для создания потокобезопасных классов
-   2.3 - Блокировка
    -   Если есть два поля зависимые друг от друга, и каждое из них атомарно, то это не потокобезопасность
    -   Если поля зависисмы, то изменения в ОБОИХ полях должны быть одной атомарной опперацией
-   2.3.1 - Внутренний замок
    -   Java предоставляет замковый механизм. Он еще называется внутренний замок
    -   Объект или метод помеченный специальной меткой, отдает свой мьютекс первому добравшемуся до него потоку. После чего другие потоки будут стоприться на этим объектах/методах, пока первый поток не вернет вернет мьютекс
-   2.3.1 - Внутренний замок(примеры)
    -   Пример synchronized метода. Аналогично synchronized(this) в который обернут весь метод

```java
public synchronized void service( ... ) { ... }
```

    - Пример synchronized для объекта

```java
public static void swap() {
    synchronized(this) { ... }
}
```

    - Пример synchronized для класса(для статических методов)

```java
public static void swap() {
    synchronized(ClassName.class) { ... }
}
```

-   2.3.2 - Повторная входимость
    -   Суть в том, что synchronized метод, внутри потока, можно вызвать без ограничений по числу раз
    -   Короче, логичное поведение
-   2.4 - Защита состояния с помощью замка
    -   Короче, вода какая-то
-   2.5 - Живучесть и производительность
    -   Примерыч того, как правильно синхронизировать два параметра внутри класса
    -   Рекомендации в духи, пиши просто а не производительно

# Глава 3 - Совместное использование объектов

-   3.1 - Видимость
    -   Опять про то, что запись из первого потока, может быть не увиденна вторым потоком
-   3.1.1 - Устаревшие данные
    -   Одно из простецких решений, для синхронизации данных в классе

```java
@ThreadSafe
public class MutableInteger {
    @GuardedBy("this") private int value;

    public synchronized int get() { return value; }
    public synchronized void set(int value) { this.value = value; }
}
```

-   3.1.2 - Неатомарные 64-битные операции
    -   Та самая штука, про которую твердил Вова
    -   double и long, могут считываться и записыватlь двумя операциями, по 32-бита. Из-за чего операция становится не атомарной
    -   не знаю насколько это актуально в 2023 году, д ив проблема вроде только на 32 битных машинах, интересно было бы проверить )
-   3.1.3 - Блокировка и видимость
    -   Чтобы обеспечить видимость актуальных значений совместных волатильных переменных, синхронизируйте читающие и пишущие потоки на общем замке

<!-- 04.12.2023: 76/464(16.37%) -->

-   3.1.4 - Волатильные переменные
    -   тут рассказывается про ключевое слово volatile
    -   никак не решает проблему многопоточности
    -   в интернете пишут, что double и long с пометкой volatile можно считать атомарными
    -   volatile - сразу же записывает в основную память, а не в кэш процессора, и любые другие потоки будут видеть это обновленное значение
        -   короче, гарантирует видимость, но не гарантирует атомарность
-   3.2 - Публикация и ускользание
    -   передать явно/не-явно ссылку на объект, который не надо было передавать, смерти подобно. Ибо все в java объекты, а объекты изменяемы внутри
    -   вообще не понял пример, про неявное ускользание this
-   3.2.1 - Приемы безопасного конструирования
    -   для безопасного конструирования, регестрируем события в методе снаружи конструктора
-   3.3 - Ограничение одним потокм - Везде потоки, поэтому используй все должны быть потокобезопасным

<!-- 04.12.2023: 82/464(17.67% + 1.3%) -->

-   3.3.1 - Ограничение одним потоком
    -   Че-то вода какая-то
-   3.3.2 - Ограничение стеком
    -   Определенное только в пределах локальной видимости, должно оставаться там
    -   И еще комент бахни, что объект не должен убежать за пределы видимости
-   3.3.3 - ThreadLocal
    -   ThreadLocal - это клас, в который можно обернуть примитив, который для каждого отдельного потока хранит копию значения
        -   Сам класс ничего не хранит. Значения храняться в потоке
        -   Когда поток прекращает работу, его значение удаляется
    -   get - получить значение для этого потока
    -   set - задать значение для этого потока
    -   withInitial - задать начальное значение
    -   remove - удаляет значение(записывает туда null)
    -   Немного фоотоп. ThreadLocalRandom - для рандомных значений в потоках

```java
public static void main(String[] args) {
    ThreadDemo threadDemo = new ThreadDemo();

    Thread t1 = new Thread(threadDemo);
    Thread t2 = new Thread(threadDemo);
    Thread t3 = new Thread(threadDemo);

    t1.start();
    t2.start();
    t3.start();

}

class ThreadDemo implements Runnable {

    int counter;
    ThreadLocal<Integer> threadLocalCounter = new ThreadLocal<>();

    public void run() {
        counter++;

        if(threadLocalCounter.get() != null) {
            threadLocalCounter.set(threadLocalCounter.get() + 1);
        } else {
            threadLocalCounter.set(0);
        }
        printCounters();
    }

    public void printCounters(){
        System.out.println("Counter: " + counter);
        System.out.println("threadLocalCounter: " + threadLocalCounter.get());
    }
}
```

-   3.4 - Немутируемость
    -   Немутируемость = Потокобезопасность
    -   Объект немутируемый если:
        -   все поля финальные
        -   ссылка на this не утекает
        -   состояние невозможно изменить после конструирования
    -   В итоге приходим к функциональщине. Все объекты немутируемы. Если надо изменить состояние, меняем ссылку на новый объект
    -   Автор пишет, что это не приводит к потере производительности
        -   Выделение памяти не так дорого как может показаться
        -   При работе с немутируемыми объектами, приходится городить структуры, которые все жрут больше
        -   Сборщик мусора быстрее работает, ибо нет поколенческого мусора
-   3.4.1 - Финальные поля
-   3.4.2 -
    -   Volatile + Немутируемость = Потокобезопасность
    -   Эта глава с примером кода
-   3.5 - Безопасная публикация
-   3.5.1 - Ненадлежащая публикация: хорошие объекты становятся плохими
    -   Даже если у вас только конструктор, это все равно может быть не потокобезопасно
    -   Если другой поток попытается получить данные, до конца работы конструктора, может прийти не то значение
-   3.5.2 - Немутируемые объекты и безопасность при инициализации
    -   Немутируемые объекты - ЛУЧШИЕ!
    -   Работу с немутируемыми объектами можно даже не синхронизировать!
    -   Но если у них в полях мутируемые объекты, то все плохо...

<!-- 05.12.2023: 92/464(19.82% + 2.15%) -->

-   3.5.3 - Приемы безопасной публикации
    -   Hashtable, synchronizedMap, ConcurrentMap - безопасно извлекаются напрямую или через иттератор
    -   Vector, CopyOnWriteArrayList, CopyOnWriteArraySet, synchronizedList, synchronizedSet - безопасно извлекаются напрямую
    -   BlockingQueue, ConcurrentLinkedQueue - безопасно извлекаются через очередь
    -   использование static поля - является самым безопасным способом публикации, т.к. происходят во время инициализации класса автоматически
-   3.5.4 - Фактически немутируемые объекты
    -   фактически немутируемые - это мутируемые объекты, но опубликованные так, что изменить их не получится
-   3.5.5 - Мутируемые объекты
    -   немутируемые объекты могут быть:
        -   опубликованы любым механизмом
    -   фактически немутируемые объекты должны быть:
        -   безопасно опубликованы;
    -   мутируемые объекты должны быть:
        -   либо безопасно опубликованы
        -   либо потокобезопасными
        -   либо защищенными замком.
-   3.5.6 - Безопасное совместное использование объектов
    -   необходимо документировать как можно работать с объектом
    -   стандартные практики:
        -   Ограничение одним потоком
            -   С объектом может работать только один поток
        -   Совместный доступ только для чтения
            -   любое число потоков
            -   только чтение
            -   не требуется никакой синхронизации
            -   к таким объектам относятся
                -   немутируемые
                -   фактически немутируемые
        -   Совместная потокобезопасность
            -   любое число потоков
            -   только обращение через публичный интерфейс
            -   не требуется никакой синхронизации
            -   к таким объектам относятся
                -   объекты выполняющие синхронизацию внутренне
        -   Защищенность
            -   для работы, требуется замок
            -   к таким объектам относятся
                -   инкапсулированному в другие потокобезопасные объекты
                -   опубликованный объект, защищенному замком

# Глава 4 - Компоновка объектов

Раздел о том, как из потокобезопасных объектов собрать потокобезопасный класс

-   4.1 - Проектирование потокобезопасного класса
-   4.1.1 - Сбор требований к синхронизации
    -   Если есть ограничения для переменной(например только положительные значения), то это поведение должо быть инкапсулированно в классе
    -   Переход класса из состояния в состояние должен быть атомарным
-   4.1.2. Операции, зависимые от состояния
    -   упоминается существование wait и notify
    -   рассказывается о встроенных блокирующих библиотечных класса - BlockinQueue, Semaphore
-   4.1.3. Владение состоянием
    -   Че-то про владение объектами... Но я ничего не понял
-   4.2. Ограничение одним экземпляром
    -   Суть в чем... Если есть непотокобезопасный объект, но он инкапсулирован в ОДИН потокбезопасный, и ссылка на него не утекает, то все окей
    -   Базовые коллекции, можно обернуть в Collections.synchronized, и они будут потокобезпасными
-   4.2.1. Мониторный шаблон Java
    -   ну просто пример с synchronized... Даже не понятно что хотел показать автор
-   4.2.2. Пример: трекинг такси
    -   в общем, hashMap оборачивают в потокобезопасную обертку
    -   оставляют единственный способ получить данные, это вызвать копирование всей hashMap
-   4.3 - Делегирование
    -   пример потокобезопасного класса на паттерне монитор(synchronized)
-   4.3.1 - Трекер такси с использованием делегирования
    -   новый код, аналогичный тому что было в предыдущей главе
    -   делегирует потокобезопасность(делает final) инкапсулированному объекту, из-за чего код становится проще
-   4.3.2 - Независимые переменные состояния
    -   если переменные состояния независимы друг от друга, то делегируй им всем потокобезопасносное состояние
-   4.3.3 - Случаи безуспешного делегирования
    -   если переменные состояния зависимы друго от друга, то если они сами потокобзопасны, класс не потокобезопасен
-   4.3.4 - Публикация базовых переменных состояния
    -   Вода
-   4.3.5 - Пример: трекер такси, публикующий свое состояние
    -   я не понимаю что хочет сказать автор (
-   4.4 - Добавление функциональности в существующие потокобезопасные классы
    -   чтобы сделать класс потокобезопасным, мы от него наследуемся и реализуем замок нужных методах... Пипец очевидные вещи от автора
-   4.4.1. Блокировка на стороне клиента
    -   добавляя потокобезопасность через наследование от класса, можно обосраться перепутов объект-замок
    -   замок нужен на объекте, КОТОРЫЙ оборачиваем, а не this
-   4.4.2. Компоновка
    -   ДА ЧТО ЖЕ ТЫ ХОЧЕШЬ СКАЗАТЬ!?
    -   Я так поняд, речь о том, что можно не через наследование(extends) а через композицию(поле хранящее оборачиваемый объект) сделать объект потокобезопасным
-   4.5. Документирование политик синхронизации
    -   Лучше писать в javadoc, что потокобезопасно, а что нет, а то как другие разработчики узнают об этом?
-   4.5.1. Толкование расплывчатой документации
    -   нет фиксации потокобезопасности в стандарте для многих классов, подразумевающих потокобезопасность
    -   автору грустно и печально

# Глава 5 - Строительные блоки

-   5.1 - Синхронизированные коллекции
-   5.1.1. Проблемы синхронизированных коллекций
    -   в главе говориться, что синхронизированные коллекции, необходимо лочить замком. Все
-   5.1.2. Итераторы и исключение ConcurrentModificationException
    -   Iterator у коллекций способен падать с ошибкой ConcurrentModificationException
    -   он как-то версионирует изменения коллекции, и может понять, что коллекция изменилась, после чего упасть
    -   так что ставим замок... как обычно, замок..
-   5.1.3. Скрытые итераторы
    -   многие методы, внутри себя работают через итераторы, поэтому неочевидно, что на них нужно ставить замок
    -   например такие методы как:
        -   toString
            -   следовательно и всякие конкатенации
        -   hashCode
        -   equals
        -   containsall, removeAll и retainAll
        -   а так же конструкторы принимающие коллекцию в качестве аргумента
-   5.2. Конкурентные коллекции
    -   оказывается есть синхронизованные классы, а есть конкуретные... Ну и что это охначает?
    -   из интернета
        -   В конкурентных коллекциях, методы таллерантны к состоянию коллекции
        -   то бишь нельзя получить элемент ннапрямую, и ошибки не падают
        -   Вместо привычных Add, Get и Remove мы используем методы TryAdd, TryGetValue и TryRemove
-   5.2.1. ConcurrentHashMap
    -   появился в Java6
    -   использует другую стратегию замков
        -   поскольку операции с hashMap могут быть долгими, замки не выгодны
        -   новая стратегия использует несколько замков для один для методов чтения, другой для методов записи
-   5.2.2. Дополнительные атомарные операции над ассоциативным массивом
    -   в ConcurrentMap некоторые операции стали атомарными
        -   «добавить, если отсутствует», «удалить, если равно» и «заменить, если равно»
-   5.2.3. CopyOnWriteArrayList
    -   List в котором иттеративный обход происходит без ошибок
    -   Просто для иттерации, ссылаемся на старый массив, а для изменений, у нас есть второй массив
-   5.3. Блокирующие очереди и паттерн «производитель-потребитель»
    -   плак-плак... Я недавно сам до этого додумался, мне казалось я гений, но это уже реализованный паттерн...
    -   в если в очереди нет элементов блоккирует "потребителя", если элементов много блокирует "производителя"
        -   в книге приведен пример с посудой. Где "производитель" - моет грязную посуду, "потребитель" - раставляет ее в шкафчике
-   5.3.1. Пример: поиск на рабочем столе
    -   водица
-   5.3.2. Серийное ограничение одним потоком
    -   а это интересно
    -   можно через блокирующие очереди "публиковать" объекты, что их мог изменить "новый владелец", а "старый владелец" их не трогал
        -   владельцы в разных потоках
-   5.3.3. Двухсторонние очереди и кража работы
    -   "кража работы" это родственный паттерн для «производитель-потребитель»
    -   суть в том, что потоки являются и «производителем" и "потребителем»
    -   свою работу каждый такой объект складывает в отдельную очередь, но когда в его очереди работа заканчивается, он идет воровать ее у другой очереди
-   5.4. Блокирующие и прерываемые методы
    -   Оказывается потоки можно прерывать... А я думал нельзя
-   5.5. Синхронизаторы
    -   синхронизатор - объект координирующий управление потоками
    -   можно определить свой или использовать стандартные
        -   Защелки
        -   FutureTask
        -   Семафоры
        -   Барьеры
-   5.5.1. Защелки
    -   стопит потоки, пока не закончится определенное действие
    -   после открытия, нельзя закрыть
    -   например класс CountDownTouch
-   5.5.2. FutureTask
    -   используется для предварительного выполнения сложных вычислений
    -   работает как защелка, только в методе Callable определяются какие-то абстрактные вычисления
-   5.5.3. Семафоры
    -   у нас есть пул потоков и есть пул разрешений. Поток не запускается и берет с собой нужные рзрешения. Следующие потоки не запустяться пока в пулл не вернутся нужные разрешения
    -   надеюсь я правильно понял...
-   5.5.4. Барьеры
    -   собирает потоки. Пока ожидаемые потоки не собирутся, барьер их не пропустит
    -   короче, "все встречаемся в 10..."
    -   приведены примере, в каких задачах можно использовать барьер
-   5.6. Создание эффективного масштабируемого кэша результатов
    -   довольно подробный пример кеширования для функции выполняющейся во многопоточном приложении
    -   можно попробовать реализовать, например с факториалом )
-   6 - Выполнение задач
-   6.1. Выполнение задач в потоках
-   6.1.1. Последовательное выполнение задач
    -   обрабатываеть запросы в одном потоке - глупо. В общем вода
-   6.1.2. Явное создание потоков для задач
    -   Главный поток - запускает задачи в отдельных потоках. Все. Вода!
-   6.1.3. Недостатки создания неограниченных потоков
    -   создание потоков - требует время. Поэтому создавать потоки для на кажду маленькую задачу глупо. А при высокой частоте обращения к серверу, вообще его положит
    -   существует лимит на число потоков. Поэтому нужно ввести верхнее ограничение, иначе начнутся тормоза
-   6.2. Фреймворк Executor
    -   класс Thread для петухов, Executor для крутанов
    -   Автор закинул удочку, что Executor лучший в мире интерфейс
-   6.2.1. Пример: веб-сервер с использованием Executor
    -   все что я понял, Executor поддерживает встроенный pool потоков. Прям при ините можно указать
-   6.2.2. Политики выполнения
    -   перед проекитрованием стоит выбрать политику исполнения, которая должна отвечать на следующие вопросы
        -   В каком потоке будут выполняться задачи?
        -   Каков порядок выполнения задач (FIFO, LIFO, приоритетный порядок)?
        -   Сколько задач может выполняться конкурентно?
        -   Сколько задач может быть поставлено в очередь?
        -   Какую задачу удалить из-за перегрузки системы и как уведомить приложение?
        -   Какие действия предпринимать до и после выполнения задачи?
-   6.2.3. Пулы потоков
    -   в Executor можно определить логику работы pool-ов
        -   newFixedThreadPool
            -   Пул потоков фиксированного размера
            -   создает определенное число потоков по мере предоставления задач
            -   старается держать размер пула постоянным
        -   newCachedThreadPool
            -   Более гибкий кэшированный пул потоков
            -   убирает простаивающие потоки и при необходимости добавляет новые
            -   не накладывая лимит на размер пула.
        -   newSingleThreadExecutor
            -   Исполнитель создает один поток для последовательной обработки задач, который при необходимости можно заменить
        -   newScheduledThreadPool
            -   пул потоков фиксированного размера
            -   периодическое выполнение задач аналогично классу Timer
-   6.2.4. Жизненный цикл исполнителя Executor
    -   Executor - отключается когда все потоки терминированы
    -   ExecutorService - расширяет executor добавляя контроль жизненного цикла. Имеет три состояния: работает, выключается и терминирован
    -   LifecycleWebServer - добавляет поддержку жизненного цикла web серверу
-   6.2.5. Отложенные и периодические задачи
    -   Timer - выполняет переодические и отложенные задачи, но имеет проблемы:
        -   если TimerTask должна выполняться каждые 10мс, а другой TimerTask выполняется 40мс, то первый либо не выполнится ни разу, либо по завершению второй, сразу четыре раза подряд
        -   если TImerTask включающийся с периодичностью - один раз упал, то следующих запланированных запусков не случится вообще
        -   поддерживает только абсолютное время, из-за чего смена часового пояса ломает Timer
    -   ScheduledThreadPoolExecutor - альтернатива Timer
        -   поддерживает только относительное время
-   6.3. Поиск эксплуатационно-пригодного параллелизма
-   6.3.1. Пример: последовательный страничный отрисовщик
-   6.3.2. Задачи, приносящие результаты: Callable и Future
    -   есть Runnable, который не возвращает результат
    -   есть Callable, который способен вернут результат отложенных вычеслений
    -   есть Future, который способен вернуть результат, проверить бала ли задача решена и еще прервать выполнение задачи
-   6.3.3. Пример: страничный отрисовщик с объектом Future
-   6.3.4. Ограничения параллелизации разнородных задач
    -   вернемся к пример с мойкой посуды
        -   работник А моет посуду, работник Б расставляет помытую посуду
        -   если мойка посуды занимает в 10 раз больше ресурсов, чем ее расстановка, то от расспаралеливания задачи мы ничего не выйграли
        -   выгоднее поставить обоих работников поставить мыть посуду
    -   чтобы параллельное выполнение задачи было выгодно, нужно чтобы задачи были
        -   независимыми
        -   однородными по затраченным ресурсам
        -   количество выгранового времени было больше, чем потрачено на создание потока
-   6.3.5. CompletionService: исполнитель Executor встречается с очередью BlockingQueue
    -   а встречаются они в ExecutorCompletionService
    -   позволяет извлекать результаты по мере выполнения распараллеленых задач
-   6.3.6. Пример: страничный отрисовщик со службой CompletionService
-   6.3.7. Наложение временнˆых ограничений на задачи
    -   Future можно использовать с тайм-аутом
-   6.3.8. Пример: портал бронирования поездок
-   7 Отмена и выключение
-   7.1. Отмена задачи
    -   в java это сделано просто, мы задаем флаг отмены, а задача должна по флагу сама определить что ей пора завершиться
-   7.1.1. Прерывание
    -   есть специальный метод, interrupt. По идее вызывает в потоке ошибку InterruptedException
    -   в плохих реализациях, классы не реагируют и програлатывают ошибку
    -   встроенные библиотечные методы, хорошо отзываеются на прерывание через специальный метод interrupt, то бишь падают
    -   бывают ситуации, когда работу по другому не прервать
-   7.1.2. Политики прерывания
    -   в главе делается большой акцент, что не задаче выделяется поток, а в выделенный поток помещается задача
    -   поток должен выключаться только его владельцем(pull-потоков), который знает о политике прерывания потока
    -   автор рекомендует, в качестве политики прерываниявыбрать отмену на уровне потока
-   7.1.3. Отклик на прерывание
    -   первый случай: прокидываем throw выше по стеку, чтобы стек мог отработать исключение
    -   второй случай: ставим флаг Thread.CurrentThread().interrupt(), чтобы стек выше мог узнать, что что-то прерывается
    -   но вообще, я ничего не понял...
-   7.1.4. Пример: хронометрированный прогон
    -   чтобы отменить задачу через секунду после начала выполнения, не надо создавать другой поток(таймер) внутри задачи
        -   это может привести к тому, что если задача закончится быстрее таймера, то таймер уронит приложение
        -   поэтому чтобы отменить поток, нужно еще не забыть отменить отмену потока )
-   7.1.5. Отмена с помощью Future
    -   поток_1.join(поток_2) - поток_1(это не точно) будет заблокирован до отработки поток_2
    -   автор предлагает делать примерно следующее, но я как обычно ничерта не понимаю

```java
public static void timedRun(Runnable r,
                            long timeout, TimeUnit unit)
                            throws InterruptedException {
    Future<?> task = taskExec.submit(r);
    try {
        task.get(timeout, unit);
    } catch (TimeoutException e) {
        // задача будет отменена ниже
    } catch (ExecutionException e) {
        // исключение выдано в задаче; выдать повторно
        throw launderThrowable(e.getCause());
    } finally {
        // Безвредно, если задача уже завершена
        task.cancel(true); // прервать, если работает
    }
}
```

-   7.1.6. Работа с непрерываемым блокированием
    -   работа с сокетами(ввод-вывод) является непрерываемой операцией
    -   чтобы убедить поток остановиться, когда он работает с непрерывемой операцией нужно понимать:
        -   закрытие базового сокета при синхронном вводве-выводе в java.io - приводит к SocketException
        -   закрытие базового сокета при синхронном вводве-выводе в java.nio - приводит к AsynchronousCloseException
        -   ...
-   7.1.7 Инкапсуляция нестандартной отмены с помощью newTaskFor
    -   newTaskFor это фабричный метод, который возвращает Future обернутый в RunnableFuture интерфейс, в котором есть метод cancel, отменяющий работу таски(потока?)
-   7.2. Остановка поточной службы
    -   приложение знает о сервисе -> сервис знает о потоках
        -   следовательно, приложение не знает о потоках
-   7.2.1. Пример: служба журналирования
    -   Автор рассказывает, что обычно служба журнала, подразумевает отдельные потоки и при выключении может залочить другие потоки
    -   но честно говоря, я опять ничего не понял )
-   7.2.2. Выключение службы ExecutorService
    -   автор говорит, что стоит предусмотреть несколько режимов выключения, жесткий (ShutdownNow) и более плавны(Shutdown)
-   7.2.3. Ядовитые таблетки
    -   вместо прерывания потока через вызов interrupt, можно создать "ядовитую таблетку"
    -   "ядовитая таблетка" - объект, начав работать с которым, поток просто прерывается
-   7.2.4. Пример: служба однократного выполнен
    -   вода какая-то
-   7.2.5. Ограничения метода shutdownNow
    -   Предполагается, что при выключении вы захотите знать, в каком состоянии были задачи
    -   Вроде не проблема и очень даже решаемо, почему глава называется ограничения - загадка
-   7.3. Обработка аномальной терминации потоков
    -   Когда падает однопоточное приложение, то это очевидно роняет приложение, когда падает поток, об этом можно и не узнать вообще
    -   Но даже так, запуск Runnable оборачивают в try...catch толь ко очень ненадежный код
        -   например, подгружаемы на ходу классы
    -   в остальном, менеджер потоков должен просто быть оповещен, что все упало(а как, я хз)
-   7.3.1. Обработчики неотловленных исключений
    -   чтобы обробатывать неотловленные исключения, существует специальный интерфейс - UncaughtExceptionHandler
    -   UncaughtExceptionHandler должен имплементировать только владелец потока
    -   можно даже зареранить поток через этот интерфейсэ
-   7.4. Выключение JVM
    -   если нет потоков - jvm выключается. Это предпочтительный вариант
    -   А как выключаться при Runtime.halt или SIGKILL
-   7.4.1. Хуки
    -   хуки
        -   jvm перед выключением запускает хуки, которые зарегистрированы с помощью метода Runtime.addShutdownHook
        -   хуки, а вернее shutdown hooks - это отдельные потоки
    -   финализаторы
        -   хуки помеченные флажком runFinalizersOnExit
    -   если хук или финализатор - зависли, то jvm не выключится

Пример регестрации хука:

```java
public void start() {
 Runtime.getRuntime().addShutdownHook(new Thread() {
 public void run() {
 try { LogService.this.stop(); }
 catch (InterruptedException ignored) {}
 }
 });
}
```

-   7.4.2. Потоки-демоны
    -   Потоки-демон - вспомогательный поток, который игнорируется jvm при выключении jvm
    -   к потокам демонам например, относятся например: сборщик мусора
    -   Есть два правила для решения, какой демон-статус имеет поток
        -   поток наследует демон-статус создавшего его потока
        -   только главный поток имеет статус нормального-потока
-   8 - Применение пулов потоков
-   8.1. Неявные стыковки между задачами и политиками выполнения
    -   вернемся к нашим баранам - задачи должны быть однородны и независимы
-   8.1.1. Взаимная блокировка с ресурсным голоданием
    -   лимит пула, может быть определен зависимыми задачами
        -   например, есть пул из 10 подключений к БД, и есть задачи зависимые от БД. Значит пул для задач - 10
    -   блокировка с ресурсным голоданием
        -   пул ограничен
        -   есть задача, которая запускает подзадачу
        -   тогда если пулл забит, задача навсегда повиснит в ожидании конца работы подзадачи
-   8.1.2. Длительные задачи
    -   если длительных задач, больше чем пул, может получиться так, что приложение застопорится, из-за заполненого пула задачами, которые не могут завершиться
    -   решение - используй хронометрированные версии классов и ставь тайм-ауты
-   8.2. Определение размера пула потоков
    -   в этой главе на удивление много конкретики
    -   для вычислительно емких задач, размер пула:
        -   $$N_cpu + 1$$
            -   N_cpu - число процессоров
        -   +1 , потому что даже вычислительно мощные потоки бывает делают отказы или берут паузу
    -   Для задач с использованием ввода вывода, требуется большой пул, вычисляемый по формуле:
        -   N*потоков = N_cpu * U*cpu * (1 + \frac{W}{C})
            -   N_cpu - число процессоров
                -   можно определить через int N_CPU = Runtime.getRuntime().availableProcessors();
            -   U_cpu - = целевая задействованность процессоров, от 0 до 1
            -   W - время ожидания
            -   C - время вычисления
    -   ну и надо помнить, что всякие БД тоже отжирают производительность
-   8.3. Конфигурирование класса ThreadPoolExecutor
    -   базовая реализация исполнителей, которую можно настроить под себя
-   8.3.1. Создание и удаление потоков
-   8.3.2. Управление задачами очереди
-   ...
-   8.4. Расширение класса ThreadPoolExecutor
    -   Был создан для расширения через beforeExecute и afterExecute
    -   Нужен для журнолирования, мониторинга и т.п.
    -   afterExecuter вызывается после завершения задачи, вне зависимости от того, как она завершилась
-   8.5 Параллелизация рекурсивных алгоритмов
    -   Это интересный пример, тут мы рекрсивно обходим дерево в одном потоке, создает список задач для обработки всех задач, и запускаем многопоточную обработку
-   9.1. Почему GUI‑интерфейсы являются однопоточными?
    -   правильный ответ, потому что многопоточные постоянно ломаются
-   9.1.1. Последовательная обработка событий
    -   события - через них по классике устроено взаимодействие интерфейса с пользователем
    -   событийный поток - поток GUI, в котором происходят события, и в который низя пихать сложновычислимые задачи
-   9.1.2. Ограничение одним потоком в Swing
    -   чк-то про Swing
-   9.2. Кратковременные задачи GUI
    -   расказывать события и их подписчиков(слушателей)
-   9.3. Длительные задачи GUI
    -   всю главу и подглавы использует Future и Runnable для создания потоков для тяжелых задач
-   9.4. Совместные модели данных
    -   примерычы отменяемых задач
-   9.4.1. Потокобезопасные модели данных
    -   CopyOnWriteArrayList
        -   при получении iterator, получаем именно то, какие данных в нем были при создании
        -   при изменении, использует типа версионирования(?)
        -   выгоден только если число чтений превышает число изменений в данных
-   9.4.2. Раздвоенные модели данных
    -   короче какая-то неважная фигня
    -   по сути, есть таблица которую видит пользователь, есть таблица в БД, они синхронизированны
    -   вот вместе они представляют раздвоенную модель
-   9.5. Другие формы однопоточных подсистем
    -   иногда однопоточность это необходимость, из-за используемых библиотек
-   10 Предотвращение сбоев жизнеспособности
    -   lock-ordering deadlock - взаимная блокировка из-за порядка блокировок
    -   resource deadlock - ресурсные взаимные блокировки
-   10.1. Взаимная блокировка
    -   в главе используется забавный пример с филосовами которые едят палочками(иллюстрирует проблему взаимных блокировок)
    -   из интересного сервера БД проектируются с задумкой что:
        -   сервера БД умеют понимать на какие ресурсы транзакции взяли Lock
        -   если две транзакции взаимно блокируются
        -   то они не должны висеть обе в ожидании
        -   чтобы они обе не висели мертвым грузом, одна убивается
-   10.1.1. Взаимные блокировки из‑за порядка блокировки
    -   если бы они оба метода пытались получить замки в одном порядке, все было бы хорошо
    -   а почему все плохо:
        -   leftRight: --- left ---------- ждем right --- ...
        -   rightLeft: --------- right --- ждем left --- ...
    -   так что, получайте замки в одном порядке!

```java
public void leftRight() {
    synchronized (left) {
        synchronized (right) {
            doSomething();
        }
    }
}

public void rightLeft() {
    synchronized (right) {
        synchronized (left) {
            doSomethingElse();
        }
    }
}
```

-   10.1.2. Взаимная блокировка из‑за динамического порядка следования замков
    -   Например, есть метод который переводит с одного счета на другой деньги, создавая блокировку на счет один а потом на счет два
    -   Если будет вызов, перевода со счета A на счет B, а потом c B на A, то случиться взаимная блокировка
    -   Чтобы порядок блокировок был всегда одинаковым, автор предлагает использовать hash-код
    -   И например если hash1 < hash2, то выполняет блокировка A потом B, иначе наоборот
-   10.1.3. Взаимные блокировки между взаимодействующими объектами
    -   в общем автор пишет, что вызвать другие методы удерживая при этом замок, может быть смертельно опасно
-   10.1.4. Открытые вызовы
    -   методы, которые вызывают методы без удержания замка, называют открытыми методами
    -   открытые методы, кончно безопаснечные
-   10.1.5. Ресурсные взаимные блокировки
    -   вспомнил типы блокировок
        -   блокировка с ресурсным голоданием
        -   Взаимные блокировки из‑за порядка блокировки
-   10.2. Предотвращение и диагностирование взаимной блокировки
    -   Если требуется приобретать многочисленные замки, то замковая упорядоченность должна стать частью проекта
    -   а лучше чтобы софт приобретал не более одного замка вообще
-   10.2.1. Хронометрированные замки
    -   tryLock - позволяет указать тайм-аут на приобретение замка
    -   если не получилось приобрести замок, можно обработать эту ситуацию
-   10.2.2. Анализ взаимной блокировки с помощью поточных дампов
    -   короче, можно анализировать взаимные блокировки
-   10.3. Другие сбои жизнеспособности
    -   существуеют и другие возможные проблемы:
        -   включая голодание
        -   пропущенные сигналы
        -   активная блокировка
-   10.3.1. Голодание
    -   Голодание (starvation) происходит, когда поток постоянно лишается доступа к ресурсам, в которых нуждается для продвижения вперед
    -   Поскольку приотритет выполнения потоков сильео зависит от платформы, не стоит в сфоих приложениях ориентроваться на приотрететы выполнения из Thread API, это только рекомендации
-   10.3.2. Слабая отзывчивость
    -   тормоза в интерфейсе
    -   с событийным потоком конкурируют процессорно-интенсивные функции
-   10.3.3. Активная блокировка
    -   Активная блокировка (livelock) — это форма сбоя жизнеспособности, в котором поток, хотя и не блокирован, по-прежнему не может продвигаться вперед, потому что продолжает повторять операцию, которая всегда будет безуспешной
    -   напримере интернет пакетов, автор предлагает добавлять случайность в задержки между вызовом методов
-   11 Производительность и масштабирование
-   11.1. Некоторые мысли о производительности
-   11.4.1. Сужение области действия замка(«вошел, вышел»)
    -   чем выше пропускная способность, тем больше смысла вообще в многопоточности
    -   чтобы повысить пропускную способность, блокировка должна быть минимальной, то есть только в нужных мкстах
-   ## 11.4.2. Сокращение степени детализации замка
-   13
-   13.1. Lock и ReentrantLock
    -   Lock и ReentrantLock - это именно интерфейс и объект(в отличии от synchronized, который является синтаксисом), способные создавать замок
    -   является более гибким аналогом synchronized
    -   замок нужно освобождать во всех ветсвях кода, а желаельно в finally
    -   мне нравиться больше )

```java
Lock lock = new ReentrantLock();
...
lock.lock();
try {
 // обновить состояние объекта
 // отловить исключения и восстановить инварианты при
 // необходимости
} finally {
 lock.unlock();
}
```

-   13.1.1. Опрашиваемое и хронометрируемое приобретение замка
    -   Lock через tryLock может проверить, если замок занят, то сделать то-то
    -   например это полезно, чтобы не создавать хрономитрированных блокировок
    -   то есть проверяем замок, если он занят, освобождаем все замки, и пробуем попозже
-   13.3. Справедливость
    -   тут вводятся такие понятия как справедливость
    -   в справедливом случае - поток ВСЕГДА ставиться в очередь, и только дождавшись своей очереди пытается получить замок
    -   в НЕ справедливом случае - поток пытается получить замок и если не вышло идет в очередь
    -   из-за длительного переключения контекста, несправедливая очередь обычно эффективнее справедливой
    -   если среднее время между запросом замков сильно больше времени на переключение, то справедливая очередь жффективнее несправедливой
-   13.4. Выбор между synchronized и ReentrantLock
    -   автор советует synchronized, из хороших аргументов:
        -   с ReentrantLock не работают потоковые дампы
        -   synchronized - встроенный механизм, а значит будет оптимизироваться лучше чем ReentrantLock
-   13.5. Замки чтения-записи
    -   ReadWriteLock - позволяет либо многим потокам читать, либо одному потоку писать
    -   ReadWriteLock может быть сконструирован как несправедливый, либо как справедивый:
        -   ReadWriteLock сконструирован как справедливый:
            -   предпочтение отдается потоку который ждал дольше всего
            -   если замком владеют читатели и поток запрашивает замок записи, то ни одному читателю больше не разрешается приобретать замок чтения, до тех пор пока писатель не будет обслужен
        -   ReadWriteLock сконструирован как НЕ справедливый:
            -   порядок, в котором потокам предоставляется доступ, не определен
            -   Разрешается понижение с писателя до читателя(Если поток владеет замком записи, то он может приобрести замок чтения, не освобождая замка записи)
-   14 Построение настраиваемых синхронизаторов
    -   FutureTask, Semaphore и BlockingQueue - зависимые от состояния классы с предусловиями. Например, нельзя извлечь результат задачи которая еще не завершена
    -   В общем, автор говорит, что а этой главе покажет как надстраивать свои очереди с условиями поверх стандартных механизмов
-   14.1. Управление зависимостью от состояния
-   14.1.1. Пример: распространение сбоя предусловия на вызывающие элементы кода
    -   В примере пример попадания в полную очередь, если не вышло, ждем в while(true) пока не выйдет
-   14.1.2. Пример: грубая блокировка с помощью опрашивания и сна
    -   В примере пример попадания в полную очередь, если не вышло, спим пкакое-то время и пытаемся снова
-   14.1.3. Очереди условий на освобождение
    -   Очереди условий (condition queue) — работают как Observable, и оповещают заинтересованных, что произошло событие
    -   В итоге используется Object.wait и Object.notifyAll
    -   Используется Object.notifyAll поскольку потоков много(просто небольшое уточнение)
-   14.2. Использование очередей условий
    -   Речь идет о низкоуровневом механизме из говна и палок
-   14.2.1. Условный предикат
    -   По словам автора, нигде не упоминается, но является основным элементом обесечивающим правильность работы "очередей условий"
    -   Тут подробненько описывается принцип работы через условные предикаты
-   14.2.3. Пропущенные сигналы
    -   В духе:
        -   ты включил тостер
        -   вышел за газетой
        -   пока тебя не было тостер отработал и дал сигнал
        -   ты вернулся и ждешь сигнала
        -   ты будешь ждать вечность
    -   В общем, если ты такое допустил, то сам лох(примерно такая мысль в главе)
-   14.2.4. Уведомление
    -   Используй notifyAll, а не notify - так безопасней, но вообще не производительно
-   14.2.5. Пример: шлюзовый класс
-   14.2.6. Вопросы безопасности подклассов
    -   Не делать подклассы базовых классов. Потому что все это очень хрупко и ломается от каждого чиха
-   14.2.7. Инкапсулирование очередей условий
-   14.2.8. Протоколы входа и выхода
    -   Протокол входа - является условным предикатом операции
    -   протокол выхода - включает в себя проверку всех переменных состояния, которые были изменены операцией, для того чтобы увидеть, могли ли они побудить какой-то другой условный предикат стать истинным, и если да, то протокол выхода включает уведомление об ассоциированной очереди условий.
-   14.3. Явные объекты условий
    -   Зачем было ебать мозги низкоуровневыми условиями, если были нормальные Condition? А, автор!?
-   14.4. Анатомия синхронизатора
    -   abstractQueuedSynchronizer(AQS) - является структурой для построения замков и синхронизаторов, на нем построены: ReentrantLock, Semaphore, CountDownLatch, ReentrantReadWriteLock, SynchronousQueue и FutureTask.
-   14.5. AbstractQueuedSynchronizer
    -   Тут автор показывает как реализовать простенькую защелку на AQS
-   14.6. AQS в классах синхронизатора библиотеки java.util.concurrent
    -   А тут описывается в общих чертах устройство блокирующих классов
-   15 Атомарные переменные и неблокирующая синхронизация
    -   Неблокирующая синхронизация - не блокируются, когда многочисленные потоки конфликтуют за одни и те же данные
    -   Алгоритмы неблокирующей синхронизации - используют низкоуровневые атомарные машинные инструкции, такие как «сравнить и обменять», вместо замков для обеспечения целостности данных при конкурентном доступе
    -   Проектировать сложнее, чем алгоритмы на основе замков
-   15.1. Недостатки замковой защиты
    -   при очень коротких операциях, замок тупо не выгоден
        -   во первых, сам замок долго создается(на фоне короткой операции)
        -   во вторых, если замок начнут оспаривать другие потоки, это прям будут сильные тормоза(на фоне короткой операции)
-   15.2. Аппаратная поддержка конкурентности
    -   «легче добыть прощение, чем разрешение»
    -   короче, у процессоров теперь есть специальные методы, дающие конкрутные приколы, в духе "найти и заменить"
-   15.2.1. Сравнить и обменять
    -   В общем, CAS(прочитать-модифицировать записать) работает так:
        -   Прочитал значение из ячейки
        -   Получил значение которое туда хочет писать
        -   Сравнивает прочитанное значение, и то которое в ячейке сейчас
        -   Если совпало - записывает
        -   Если нет, то пытается снова
    -   В итоге CAS при большом числе потоков, у какого-то одного получается, а потом у другого и т.д.
-   15.2.2. Неблокирующий счетчик
    -   CAS быстрее замков в оптимистичных ситуациях и медленнее в пессимистичных
-   15.2.3. Поддержка операции CAS в JVM
    -   Начиная с Java5.0, добавлена низкоуровневая поддержка CAS
-   15.3. Классы атомарных переменных
-   15.4. Неблокирующие алгоритмы
    -   Есть CAS алгоритмы для различных структур данных (таблицы, стек и т.д.), так что свое можно не выдумывать
-   15.4.4. Проблема ABA
    -   Бывает что значение изменилось несколько раз и вернулась в начальное состояние
    -   Тогд CAS отрабает словно ничего не менялось
    -   Бывают алгоритмы, для которых факт, произошедших изменений важен, автор предлагает версионирование
-   16 Модель памяти Java
-   16.1. Что такое модель памяти и зачем она нужна?
    -   Вода какая-то
-   16.1.1. Платформенные модели памяти
-   16.1.2. Переупорядочивание
