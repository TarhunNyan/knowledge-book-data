# Брайн Гетц - Java Concurrency на практике

Книга старенькая, 2006 года. Но вроде как классика, написанная людьми занимавшимися проектированием механизмов многопоточности в Java

# Глава 1 - Введение

Вводная вода:

-   до 1.2.2 идет лирике о том насколько потоки полезны и круты
-   1.2.2 - Простота моделирования
    -   Сервлеты
        -   асинхронную работу, разбиваем на несколько синхронных потоков данных
        -   Эти данные попадают в отдельные потоки
        -   Потоки взаимодействуют друг с другом только в отдельных точках синхронизации
-   1.2.3 - Упрощенная обработка асинхронных событий
    -   Речь о том, что раньше было ограничение на число потоков на уровне опперационных систем. Поэтому приходилось развивать асинхронные методы чтения/записи
    -   В Java есть библиотека(java.nio), которая позволяет обойти ограничение на число потоков
        -   Библиотека была настолько крута, что в Linux ввели копию этого механизма
-   1.2.4 - Более отзывчивые пользовательские интерфейсы
    -   В общем, раньше все было в одном потоке. И GUI и логика, что было плохо. Теперь GUI работает в отдельном потоке, и вызывает обработчики

Наконец чутка практики:

-   1.3.1 - Угрозы безопасности
    -   Простенький пример, показывающий что есть потоконебезопасный код
    -   Вводятся специальные аннотации
        -   @NotThreadSafe - не потокобезопасный класс(если у класса нет @ThreadSafe, то по определению класс не потокобезопасный)
        -   @ThreadSafe - потокобезопасный класс
        -   @Immutable - класс является неммутируемым(данные внутри неизменяемы). Следовательно потокобезопасным
-   1.3.2 - Сбои жизнеспособности
    -   Безопасность(safety) - подразумевает отсутствие плохих состояний
    -   Жизнеспособность(liveness) - преодоление плохих состояний с хорошим исходом
    -   Упоминаются
        -   Deadlock(взаимная блокировка)
        -   Starvation(голодание)
        -   Livelock(активную блокировку)
-   1.4 - Потоки везде
    -   Тут нас пугают, что потоки не опциональная возможность, а обязательное знание
    -   Всякие сборщики мусора, Swing, Timer, AWT - создают потоки, а значит классы должны быть потокобезопасными(лол)
    -   Идут пояснение, почему многопоточность, как зараза. И что во многих местах требуется @ThreadSafe

# Глава 2 - Потокобезопасность

-   2.1 - Потокобезопасность
    -   Дается определение thread-safety(потокобезопасносный класс)
        -   Если класс ведет себя правильно во время доступа из многочисленных потоков и не требует координации со стороны вызывающего кода
-   2.1.1 - Пример сервлетов без поддержки внутреннего состояния
-   2.2 - Атомарность
    -   Тут приводится пояснение, что такое атомарность. И что не атомарные операция - не потокобезопасны, потому что может поменяться состояние
-   2.2.1 - Состояние гонки
    -   Пример с описанием того, что имеется ввиду под состоянием гонки
    -   Пример описывает ситуацию встречи с другом в точке А или Б
-   2.2.2 - Пример: состояние гонки в ленивой инициализации
    -   Короче, классический синглтон, оказался не потокобезопасным
-   2.2.3 - Составные действия
    -   Составные действия
        -   check-then-act(проверить потом действовтать)
        -   read-modify-write(прочитать изменить записать)
    -   Составные действия - являются источником проблем для потокобезопасности
    -   Составные действия - должны быть атомарными
    -   Приводится пример, для создание потокобезопасного счетчика
        -   java.util.concurrent.atomic - пакет в котором валяются атомарные, потокобезопасные операции
        -   AtomicLomg - класс из пакета java.util.concurrent.atomic, который использовался в примере
    -   Вывод, используйте потокобезопасные классы, для создания потокобезопасных классов
-   2.3 - Блокировка
    -   Если есть два поля зависимые друг от друга, и каждое из них атомарно, то это не потокобезопасность
    -   Если поля зависисмы, то изменения в ОБОИХ полях должны быть одной атомарной опперацией
-   2.3.1 - Внутренний замок
    -   Java предоставляет замковый механизм. Он еще называется внутренний замок
    -   Объект или метод помеченный специальной меткой, отдает свой мьютекс первому добравшемуся до него потоку. После чего другие потоки будут стоприться на этиъ объектах/методах, пока первый поток не вернет вернет мьютекс
-   2.3.1 - Внутренний замок(примеры)
    -   Пример synchronized метода. Аналогично synchronized(this) в который обернут весь метод

```java
public synchronized void service( ... ) { ... }
```

    - Пример synchronized для объекта

```java
public static void swap() {
    synchronized(this) { ... }
}
```

    - Пример synchronized для класса(для статических методов)

```java
public static void swap() {
    synchronized(ClassName.class) { ... }
}
```

-   2.3.2 - Повторная входимость
    -   Суть в том, что synchronized метод, внутри потока, можно вызвать без ограничений по числу раз
    -   Короче, логичное поведение
-   2.4 - Защита состояния с помощью замка
    -   Короче, вода какая-то
-   2.5 - Живучесть и производительность
    -   Примерыч того, как правильно синхронизировать два параметра внутри класса
    -   Рекомендации в духи, пиши просто а не производительно

# Глава 3 - Совместное использование объектов

-   3.1 - Видимость
    -   Опять про то, что запись из первого потока, может быть не увиденна вторым потоком
-   3.1.1 - Устаревшие данные
    -   Одно из простецких решений, для синхронизации данных в классе

```java
@ThreadSafe
public class MutableInteger {
    @GuardedBy("this") private int value;

    public synchronized int get() { return value; }
    public synchronized void set(int value) { this.value = value; }
}
```

-   3.1.2 - Неатомарные 64-битные операции
    -   Та самая штука, про которую твердил Вова
    -   double и long, могут считываться и записыватlь двумя операциями, по 32-бита. Из-за чего операция становится не атомарной
    -   не знаю насколько это актуально в 2023 году, д ив проблема вроде только на 32 битных машинах, интересно было бы проверить )
-   3.1.3 - Блокировка и видимость
    -   Чтобы обеспечить видимость актуальных значений совместных волатильных переменных, синхронизируйте читающие и пишущие потоки на общем замке

<!-- 04.12.2023: 76/464(16.37%) -->

-   3.1.4 - Волатильные переменные
    -   тут рассказывается про ключевое слово volatile
    -   никак не решает проблему многопоточности
    -   в интернете пишут, что double и long с пометкой volatile можно считать атомарными
    -   volatile - сразу же записывает в основную память, а не в кэш процессора, и любые другие потоки будут видеть это обновленное значение
        -   короче, гарантирует видимость, но не гарантирует атомарность
-   3.2 - Публикация и ускользание
    -   передать явно/не-явно ссылку на объект, который не надо было передавать, смерти подобно. Ибо все в java объекты, а объекты изменяемы внутри
    -   вообще не понял пример, про неявное ускользание this
-   3.2.1 - Приемы безопасного конструирования
    -   для безопасного конструирования, регестрируем события в методе снаружи конструктора
-   3.3 - Ограничение одним потокм - Везде потоки, поэтому используй все должны быть потокобезопасным

<!-- 04.12.2023: 82/464(17.67% + 1.3%) -->

-   3.3.1 - Ограничение одним потоком
    -   Че-то вода какая-то
-   3.3.2 - Ограничение стеком
    -   Определенное только в пределах локальной видимости, должно оставаться там
    -   И еще комент бахни, что объект не должен убежать за пределы видимости
-   3.3.3 - ThreadLocal
    -   ThreadLocal - это клас, в который можно обернуть примитив, который для каждого отдельного потока хранит копию значения
        -   Сам класс ничего не хранит. Значения храняться в потоке
        -   Когда поток прекращает работу, его значение удаляется
    -   get - получить значение для этого потока
    -   set - задать значение для этого потока
    -   withInitial - задать начальное значение
    -   remove - удаляет значение(записывает туда null)
    -   Немного фоотоп. ThreadLocalRandom - для рандомных значений в потоках

```java
public static void main(String[] args) {
    ThreadDemo threadDemo = new ThreadDemo();

    Thread t1 = new Thread(threadDemo);
    Thread t2 = new Thread(threadDemo);
    Thread t3 = new Thread(threadDemo);

    t1.start();
    t2.start();
    t3.start();

}

class ThreadDemo implements Runnable {

    int counter;
    ThreadLocal<Integer> threadLocalCounter = new ThreadLocal<>();

    public void run() {
        counter++;

        if(threadLocalCounter.get() != null) {
            threadLocalCounter.set(threadLocalCounter.get() + 1);
        } else {
            threadLocalCounter.set(0);
        }
        printCounters();
    }

    public void printCounters(){
        System.out.println("Counter: " + counter);
        System.out.println("threadLocalCounter: " + threadLocalCounter.get());
    }
}
```

-   3.4 - Немутируемость
    -   Немутируемость = Потокобезопасность
    -   Объект немутируемый если:
        -   все поля финальные
        -   ссылка на this не утекает
        -   состояние невозможно изменить после конструирования
    -   В итоге приходим к функциональщине. Все объекты немутируемы. Если надо изменить состояние, меняем ссылку на новый объект
    -   Автор пишет, что это не приводит к потере производительности
        -   Выделение памяти не так дорого как может показаться
        -   При работе с немутируемыми объектами, приходится городить структуры, которые все жрут больше
        -   Сборщик мусора быстрее работает, ибо нет поколенческого мусора
-   3.4.1 - Финальные поля
-   3.4.2 -
    -   Volatile + Немутируемость = Потокобезопасность
    -   Эта глава с примером кода
-   3.5 - Безопасная публикация
-   3.5.1 - Ненадлежащая публикация: хорошие объекты становятся плохими
    -   Даже если у вас только конструктор, это все равно может быть не потокобезопасно
    -   Если другой поток попытается получить данные, до конца работы конструктора, может прийти не то значение
-   3.5.2 - Немутируемые объекты и безопасность при инициализации
    -   Немутируемые объекты - ЛУЧШИЕ!
    -   Работу с немутируемыми объектами можно даже не синхронизировать!
    -   Но если у них в полях мутируемые объекты, то все плохо...

<!-- 05.12.2023: 92/464(19.82% + 2.15%) -->

-   3.5.3 - Приемы безопасной публикации
    -   Hashtable, synchronizedMap, ConcurrentMap - безопасно извлекаются напрямую или через иттератор
    -   Vector, CopyOnWriteArrayList, CopyOnWriteArraySet, synchronizedList, synchronizedSet - безопасно извлекаются напрямую
    -   BlockingQueue, ConcurrentLinkedQueue - безопасно извлекаются через очередь
    -   использование static поля - является самым безопасным способом публикации, т.к. происходят во время инициализации класса автоматически
-   3.5.4 - Фактически немутируемые объекты
    -   фактически немутируемые - это мутируемые объекты, но опубликованные так, что изменить их не получится
-   3.5.5 - Мутируемые объекты
    -   немутируемые объекты могут быть:
        -   опубликованы любым механизмом
    -   фактически немутируемые объекты должны быть:
        -   безопасно опубликованы;
    -   мутируемые объекты должны быть:
        -   либо безопасно опубликованы
        -   либо потокобезопасными
        -   либо защищенными замком.
-   3.5.6 - Безопасное совместное использование объектов
    -   необходимо документировать как можно работать с объектом
    -   стандартные практики:
        -   Ограничение одним потоком
            -   С объектом может работать только один поток
        -   Совместный доступ только для чтения
            -   любое число потоков
            -   только чтение
            -   не требуется никакой синхронизации
            -   к таким объектам относятся
                -   немутируемые
                -   фактически немутируемые
        -   Совместная потокобезопасность
            -   любое число потоков
            -   только обращение через публичный интерфейс
            -   не требуется никакой синхронизации
            -   к таким объектам относятся
                -   объекты выполняющие синхронизацию внутренне
        -   Защищенность
            -   для работы, требуется замок
            -   к таким объектам относятся
                -   инкапсулированному в другие потокобезопасные объекты
                -   опубликованный объект, защищенному замком

# Глава 4 - Компоновка объектов

Раздел о том, как из потокобезопасных объектов собрать потокобезопасный класс

-   4.1 - Проектирование потокобезопасного класса
-   4.1.1 - Сбор требований к синхронизации
    -   Если есть ограничения для переменной(например только положительные значения), то это поведение должо быть инкапсулированно в классе
    -   Переход класса из состояния в состояние должен быть атомарным
-   4.1.2. Операции, зависимые от состояния
    -   упоминается существование wait и notify
    -   рассказывается о встроенных блокирующих библиотечных класса - BlockinQueue, Semaphore
-   4.1.3. Владение состоянием
    -   Че-то про владение объектами... Но я ничего не понял
-   4.2. Ограничение одним экземпляром
    -   Суть в чем... Если есть непотокобезопасный объект, но он инкапсулирован в ОДИН потокбезопасный, и ссылка на него не утекает, то все окей
    -   Базовые коллекции, можно обернуть в Collections.synchronized, и они будут потокобезпасными
-   4.2.1. Мониторный шаблон Java
    -   ну просто пример с synchronized... Даже не понятно что хотел показать автор
-   4.2.2. Пример: трекинг такси
    -
