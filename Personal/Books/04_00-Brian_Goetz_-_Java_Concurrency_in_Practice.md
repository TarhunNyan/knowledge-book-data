# Брайн Гетц - Java Concurrency на практике

Книга старенькая, 2006 года. Но вроде как классика, написанная людьми занимавшимися проектированием механизмов многопоточности в Java

# Глава 1 - Введение

Вводная вода:

-   до 1.2.2 идет лирике о том насколько потоки полезны и круты
-   1.2.2 - Простота моделирования
    -   Сервлеты
        -   асинхронную работу, разбиваем на несколько синхронных потоков данных
        -   Эти данные попадают в отдельные потоки
        -   Потоки взаимодействуют друг с другом только в отдельных точках синхронизации
-   1.2.3 - Упрощенная обработка асинхронных событий
    -   Речь о том, что раньше было ограничение на число потоков на уровне опперационных систем. Поэтому приходилось развивать асинхронные методы чтения/записи
    -   В Java есть библиотека(java.nio), которая позволяет обойти ограничение на число потоков
        -   Библиотека была настолько крута, что в Linux ввели копию этого механизма
-   1.2.4 - Более отзывчивые пользовательские интерфейсы
    -   В общем, раньше все было в одном потоке. И GUI и логика, что было плохо. Теперь GUI работает в отдельном потоке, и вызывает обработчики

Наконец чутка практики:

-   1.3.1 - Угрозы безопасности
    -   Простенький пример, показывающий что есть потоконебезопасный код
    -   Вводятся специальные аннотации
        -   @NotThreadSafe - не потокобезопасный класс(если у класса нет @ThreadSafe, то по определению класс не потокобезопасный)
        -   @ThreadSafe - потокобезопасный класс
        -   @Immutable - класс является неммутируемым(данные внутри неизменяемы). Следовательно потокобезопасным
-   1.3.2 - Сбои жизнеспособности
    -   Безопасность(safety) - подразумевает отсутствие плохих состояний
    -   Жизнеспособность(liveness) - преодоление плохих состояний с хорошим исходом
    -   Упоминаются
        -   Deadlock(взаимная блокировка)
        -   Starvation(голодание)
        -   Livelock(активную блокировку)
-   1.4 - Потоки везде
    -   Тут нас пугают, что потоки не опциональная возможность, а обязательное знание
    -   Всякие сборщики мусора, Swing, Timer, AWT - создают потоки, а значит классы должны быть потокобезопасными(лол)
    -   Идут пояснение, почему многопоточность, как зараза. И что во многих местах требуется @ThreadSafe

# Глава 2 - Потокобезопасность

-   2.1 - Потокобезопасность
    -   Дается определение thread-safety(потокобезопасносный класс)
        -   Если класс ведет себя правильно во время доступа из многочисленных потоков и не требует координации со стороны вызывающего кода
-   2.1.1 - Пример сервлетов без поддержки внутреннего состояния
-   2.2 - Атомарность
    -   Тут приводится пояснение, что такое атомарность. И что не атомарные операция - не потокобезопасны, потому что может поменяться состояние
-   2.2.1 - Состояние гонки
    -   Пример с описанием того, что имеется ввиду под состоянием гонки
    -   Пример описывает ситуацию встречи с другом в точке А или Б
-   2.2.2 - Пример: состояние гонки в ленивой инициализации
    -   Короче, классический синглтон, оказался не потокобезопасным
-   2.2.3 - Составные действия
    -   Составные действия
        -   check-then-act(проверить потом действовтать)
        -   read-modify-write(прочитать изменить записать)
    -   Составные действия - являются источником проблем для потокобезопасности
    -   Составные действия - должны быть атомарными
    -   Приводится пример, для создание потокобезопасного счетчика
        -   java.util.concurrent.atomic - пакет в котором валяются атомарные, потокобезопасные операции
        -   AtomicLomg - класс из пакета java.util.concurrent.atomic, который использовался в примере
    -   Вывод, используйте потокобезопасные классы, для создания потокобезопасных классов
-   2.3 - Блокировка
    -   Если есть два поля зависимые друг от друга, и каждое из них атомарно, то это не потокобезопасность
    -   Если поля зависисмы, то изменения в ОБОИХ полях должны быть одной атомарной опперацией
-   2.3.1 - Внутренний замок
    -   Java предоставляет замковый механизм. Он еще называется внутренний замок
    -   Объект или метод помеченный специальной меткой, отдает свой мьютекс первому добравшемуся до него потоку. После чего другие потоки будут стоприться на этим объектах/методах, пока первый поток не вернет вернет мьютекс
-   2.3.1 - Внутренний замок(примеры)
    -   Пример synchronized метода. Аналогично synchronized(this) в который обернут весь метод

```java
public synchronized void service( ... ) { ... }
```

    - Пример synchronized для объекта

```java
public static void swap() {
    synchronized(this) { ... }
}
```

    - Пример synchronized для класса(для статических методов)

```java
public static void swap() {
    synchronized(ClassName.class) { ... }
}
```

-   2.3.2 - Повторная входимость
    -   Суть в том, что synchronized метод, внутри потока, можно вызвать без ограничений по числу раз
    -   Короче, логичное поведение
-   2.4 - Защита состояния с помощью замка
    -   Короче, вода какая-то
-   2.5 - Живучесть и производительность
    -   Примерыч того, как правильно синхронизировать два параметра внутри класса
    -   Рекомендации в духи, пиши просто а не производительно

# Глава 3 - Совместное использование объектов

-   3.1 - Видимость
    -   Опять про то, что запись из первого потока, может быть не увиденна вторым потоком
-   3.1.1 - Устаревшие данные
    -   Одно из простецких решений, для синхронизации данных в классе

```java
@ThreadSafe
public class MutableInteger {
    @GuardedBy("this") private int value;

    public synchronized int get() { return value; }
    public synchronized void set(int value) { this.value = value; }
}
```

-   3.1.2 - Неатомарные 64-битные операции
    -   Та самая штука, про которую твердил Вова
    -   double и long, могут считываться и записыватlь двумя операциями, по 32-бита. Из-за чего операция становится не атомарной
    -   не знаю насколько это актуально в 2023 году, д ив проблема вроде только на 32 битных машинах, интересно было бы проверить )
-   3.1.3 - Блокировка и видимость
    -   Чтобы обеспечить видимость актуальных значений совместных волатильных переменных, синхронизируйте читающие и пишущие потоки на общем замке

<!-- 04.12.2023: 76/464(16.37%) -->

-   3.1.4 - Волатильные переменные
    -   тут рассказывается про ключевое слово volatile
    -   никак не решает проблему многопоточности
    -   в интернете пишут, что double и long с пометкой volatile можно считать атомарными
    -   volatile - сразу же записывает в основную память, а не в кэш процессора, и любые другие потоки будут видеть это обновленное значение
        -   короче, гарантирует видимость, но не гарантирует атомарность
-   3.2 - Публикация и ускользание
    -   передать явно/не-явно ссылку на объект, который не надо было передавать, смерти подобно. Ибо все в java объекты, а объекты изменяемы внутри
    -   вообще не понял пример, про неявное ускользание this
-   3.2.1 - Приемы безопасного конструирования
    -   для безопасного конструирования, регестрируем события в методе снаружи конструктора
-   3.3 - Ограничение одним потокм - Везде потоки, поэтому используй все должны быть потокобезопасным

<!-- 04.12.2023: 82/464(17.67% + 1.3%) -->

-   3.3.1 - Ограничение одним потоком
    -   Че-то вода какая-то
-   3.3.2 - Ограничение стеком
    -   Определенное только в пределах локальной видимости, должно оставаться там
    -   И еще комент бахни, что объект не должен убежать за пределы видимости
-   3.3.3 - ThreadLocal
    -   ThreadLocal - это клас, в который можно обернуть примитив, который для каждого отдельного потока хранит копию значения
        -   Сам класс ничего не хранит. Значения храняться в потоке
        -   Когда поток прекращает работу, его значение удаляется
    -   get - получить значение для этого потока
    -   set - задать значение для этого потока
    -   withInitial - задать начальное значение
    -   remove - удаляет значение(записывает туда null)
    -   Немного фоотоп. ThreadLocalRandom - для рандомных значений в потоках

```java
public static void main(String[] args) {
    ThreadDemo threadDemo = new ThreadDemo();

    Thread t1 = new Thread(threadDemo);
    Thread t2 = new Thread(threadDemo);
    Thread t3 = new Thread(threadDemo);

    t1.start();
    t2.start();
    t3.start();

}

class ThreadDemo implements Runnable {

    int counter;
    ThreadLocal<Integer> threadLocalCounter = new ThreadLocal<>();

    public void run() {
        counter++;

        if(threadLocalCounter.get() != null) {
            threadLocalCounter.set(threadLocalCounter.get() + 1);
        } else {
            threadLocalCounter.set(0);
        }
        printCounters();
    }

    public void printCounters(){
        System.out.println("Counter: " + counter);
        System.out.println("threadLocalCounter: " + threadLocalCounter.get());
    }
}
```

-   3.4 - Немутируемость
    -   Немутируемость = Потокобезопасность
    -   Объект немутируемый если:
        -   все поля финальные
        -   ссылка на this не утекает
        -   состояние невозможно изменить после конструирования
    -   В итоге приходим к функциональщине. Все объекты немутируемы. Если надо изменить состояние, меняем ссылку на новый объект
    -   Автор пишет, что это не приводит к потере производительности
        -   Выделение памяти не так дорого как может показаться
        -   При работе с немутируемыми объектами, приходится городить структуры, которые все жрут больше
        -   Сборщик мусора быстрее работает, ибо нет поколенческого мусора
-   3.4.1 - Финальные поля
-   3.4.2 -
    -   Volatile + Немутируемость = Потокобезопасность
    -   Эта глава с примером кода
-   3.5 - Безопасная публикация
-   3.5.1 - Ненадлежащая публикация: хорошие объекты становятся плохими
    -   Даже если у вас только конструктор, это все равно может быть не потокобезопасно
    -   Если другой поток попытается получить данные, до конца работы конструктора, может прийти не то значение
-   3.5.2 - Немутируемые объекты и безопасность при инициализации
    -   Немутируемые объекты - ЛУЧШИЕ!
    -   Работу с немутируемыми объектами можно даже не синхронизировать!
    -   Но если у них в полях мутируемые объекты, то все плохо...

<!-- 05.12.2023: 92/464(19.82% + 2.15%) -->

-   3.5.3 - Приемы безопасной публикации
    -   Hashtable, synchronizedMap, ConcurrentMap - безопасно извлекаются напрямую или через иттератор
    -   Vector, CopyOnWriteArrayList, CopyOnWriteArraySet, synchronizedList, synchronizedSet - безопасно извлекаются напрямую
    -   BlockingQueue, ConcurrentLinkedQueue - безопасно извлекаются через очередь
    -   использование static поля - является самым безопасным способом публикации, т.к. происходят во время инициализации класса автоматически
-   3.5.4 - Фактически немутируемые объекты
    -   фактически немутируемые - это мутируемые объекты, но опубликованные так, что изменить их не получится
-   3.5.5 - Мутируемые объекты
    -   немутируемые объекты могут быть:
        -   опубликованы любым механизмом
    -   фактически немутируемые объекты должны быть:
        -   безопасно опубликованы;
    -   мутируемые объекты должны быть:
        -   либо безопасно опубликованы
        -   либо потокобезопасными
        -   либо защищенными замком.
-   3.5.6 - Безопасное совместное использование объектов
    -   необходимо документировать как можно работать с объектом
    -   стандартные практики:
        -   Ограничение одним потоком
            -   С объектом может работать только один поток
        -   Совместный доступ только для чтения
            -   любое число потоков
            -   только чтение
            -   не требуется никакой синхронизации
            -   к таким объектам относятся
                -   немутируемые
                -   фактически немутируемые
        -   Совместная потокобезопасность
            -   любое число потоков
            -   только обращение через публичный интерфейс
            -   не требуется никакой синхронизации
            -   к таким объектам относятся
                -   объекты выполняющие синхронизацию внутренне
        -   Защищенность
            -   для работы, требуется замок
            -   к таким объектам относятся
                -   инкапсулированному в другие потокобезопасные объекты
                -   опубликованный объект, защищенному замком

# Глава 4 - Компоновка объектов

Раздел о том, как из потокобезопасных объектов собрать потокобезопасный класс

-   4.1 - Проектирование потокобезопасного класса
-   4.1.1 - Сбор требований к синхронизации
    -   Если есть ограничения для переменной(например только положительные значения), то это поведение должо быть инкапсулированно в классе
    -   Переход класса из состояния в состояние должен быть атомарным
-   4.1.2. Операции, зависимые от состояния
    -   упоминается существование wait и notify
    -   рассказывается о встроенных блокирующих библиотечных класса - BlockinQueue, Semaphore
-   4.1.3. Владение состоянием
    -   Че-то про владение объектами... Но я ничего не понял
-   4.2. Ограничение одним экземпляром
    -   Суть в чем... Если есть непотокобезопасный объект, но он инкапсулирован в ОДИН потокбезопасный, и ссылка на него не утекает, то все окей
    -   Базовые коллекции, можно обернуть в Collections.synchronized, и они будут потокобезпасными
-   4.2.1. Мониторный шаблон Java
    -   ну просто пример с synchronized... Даже не понятно что хотел показать автор
-   4.2.2. Пример: трекинг такси
    -   в общем, hashMap оборачивают в потокобезопасную обертку
    -   оставляют единственный способ получить данные, это вызвать копирование всей hashMap
-   4.3 - Делегирование
    -   пример потокобезопасного класса на паттерне монитор(synchronized)
-   4.3.1 - Трекер такси с использованием делегирования
    -   новый код, аналогичный тому что было в предыдущей главе
    -   делегирует потокобезопасность(делает final) инкапсулированному объекту, из-за чего код становится проще
-   4.3.2 - Независимые переменные состояния
    -   если переменные состояния независимы друг от друга, то делегируй им всем потокобезопасносное состояние
-   4.3.3 - Случаи безуспешного делегирования
    -   если переменные состояния зависимы друго от друга, то если они сами потокобзопасны, класс не потокобезопасен
-   4.3.4 - Публикация базовых переменных состояния
    -   Вода
-   4.3.5 - Пример: трекер такси, публикующий свое состояние
    -   я не понимаю что хочет сказать автор (
-   4.4 - Добавление функциональности в существующие потокобезопасные классы
    -   чтобы сделать класс потокобезопасным, мы от него наследуемся и реализуем замок нужных методах... Пипец очевидные вещи от автора
-   4.4.1. Блокировка на стороне клиента
    -   добавляя потокобезопасность через наследование от класса, можно обосраться перепутов объект-замок
    -   замок нужен на объекте, КОТОРЫЙ оборачиваем, а не this
-   4.4.2. Компоновка
    -   ДА ЧТО ЖЕ ТЫ ХОЧЕШЬ СКАЗАТЬ!?
    -   Я так поняд, речь о том, что можно не через наследование(extends) а через композицию(поле хранящее оборачиваемый объект) сделать объект потокобезопасным
-   4.5. Документирование политик синхронизации
    -   Лучше писать в javadoc, что потокобезопасно, а что нет, а то как другие разработчики узнают об этом?
-   4.5.1. Толкование расплывчатой документации
    -   нет фиксации потокобезопасности в стандарте для многих классов, подразумевающих потокобезопасность
    -   автору грустно и печально

# Глава 5 - Строительные блоки

-   5.1 - Синхронизированные коллекции
-   5.1.1. Проблемы синхронизированных коллекций
    -   в главе говориться, что синхронизированные коллекции, необходимо лочить замком. Все
-   5.1.2. Итераторы и исключение ConcurrentModificationException
    -   Iterator у коллекций способен падать с ошибкой ConcurrentModificationException
    -   он как-то версионирует изменения коллекции, и может понять, что коллекция изменилась, после чего упасть
    -   так что ставим замок... как обычно, замок..
-   5.1.3. Скрытые итераторы
    -   многие методы, внутри себя работают через итераторы, поэтому неочевидно, что на них нужно ставить замок
    -   например такие методы как:
        -   toString
            -   следовательно и всякие конкатенации
        -   hashCode
        -   equals
        -   containsall, removeAll и retainAll
        -   а так же конструкторы принимающие коллекцию в качестве аргумента
-   5.2. Конкурентные коллекции
    -   оказывается есть синхронизованные классы, а есть конкуретные... Ну и что это охначает?
    -   из интернета
        -   В конкурентных коллекциях, методы таллерантны к состоянию коллекции
        -   то бишь нельзя получить элемент ннапрямую, и ошибки не падают
        -   Вместо привычных Add, Get и Remove мы используем методы TryAdd, TryGetValue и TryRemove
-   5.2.1. ConcurrentHashMap
    -   появился в Java6
    -   использует другую стратегию замков
        -   поскольку операции с hashMap могут быть долгими, замки не выгодны
        -   новая стратегия использует несколько замков для один для методов чтения, другой для методов записи
-   5.2.2. Дополнительные атомарные операции над ассоциативным массивом
    -   в ConcurrentMap некоторые операции стали атомарными
        -   «добавить, если отсутствует», «удалить, если равно» и «заменить, если равно»
-   5.2.3. CopyOnWriteArrayList
    -   List в котором иттеративный обход происходит без ошибок
    -   Просто для иттерации, ссылаемся на старый массив, а для изменений, у нас есть второй массив
-   5.3. Блокирующие очереди и паттерн «производитель-потребитель»
    -   плак-плак... Я недавно сам до этого додумался, мне казалось я гений, но это уже реализованный паттерн...
    -   в если в очереди нет элементов блоккирует "потребителя", если элементов много блокирует "производителя"
        -   в книге приведен пример с посудой. Где "производитель" - моет грязную посуду, "потребитель" - раставляет ее в шкафчике
-   5.3.1. Пример: поиск на рабочем столе
    -   водица
-   5.3.2. Серийное ограничение одним потоком
    -   а это интересно
    -   можно через блокирующие очереди "публиковать" объекты, что их мог изменить "новый владелец", а "старый владелец" их не трогал
        -   владельцы в разных потоках
-   5.3.3. Двухсторонние очереди и кража работы
    -   "кража работы" это родственный паттерн для «производитель-потребитель»
    -   суть в том, что потоки являются и «производителем" и "потребителем»
    -   свою работу каждый такой объект складывает в отдельную очередь, но когда в его очереди работа заканчивается, он идет воровать ее у другой очереди
-   5.4. Блокирующие и прерываемые методы
    -   Оказывается потоки можно прерывать... А я думал нельзя
-   5.5. Синхронизаторы
    -   синхронизатор - объект координирующий управление потоками
    -   можно определить свой или использовать стандартные
        -   Защелки
        -   FutureTask
        -   Семафоры
        -   Барьеры
-   5.5.1. Защелки
    -   стопит потоки, пока не закончится определенное действие
    -   после открытия, нельзя закрыть
    -   например класс CountDownTouch
-   5.5.2. FutureTask
    -   используется для предварительного выполнения сложных вычислений
    -   работает как защелка, только в методе Callable определяются какие-то абстрактные вычисления
-   5.5.3. Семафоры
    -   у нас есть пул потоков и есть пул разрешений. Поток не запускается и берет с собой нужные рзрешения. Следующие потоки не запустяться пока в пулл не вернутся нужные разрешения
    -   надеюсь я правильно понял...
-   5.5.4. Барьеры
    -   собирает потоки. Пока ожидаемые потоки не собирутся, барьер их не пропустит
    -   короче, "все встречаемся в 10..."
    -   приведены примере, в каких задачах можно использовать барьер
-   5.6. Создание эффективного масштабируемого кэша результатов
    -   довольно подробный пример кеширования для функции выполняющейся во многопоточном приложении
    -   можно попробовать реализовать, например с факториалом )
-   6 - Выполнение задач
-   6.1. Выполнение задач в потоках
-   6.1.1. Последовательное выполнение задач
    -   обрабатываеть запросы в одном потоке - глупо. В общем вода
-   6.1.2. Явное создание потоков для задач
    -   Главный поток - запускает задачи в отдельных потоках. Все. Вода!
-   6.1.3. Недостатки создания неограниченных потоков
    -   создание потоков - требует время. Поэтому создавать потоки для на кажду маленькую задачу глупо. А при высокой частоте обращения к серверу, вообще его положит
    -   существует лимит на число потоков. Поэтому нужно ввести верхнее ограничение, иначе начнутся тормоза
-   6.2. Фреймворк Executor
    -   класс Thread для петухов, Executor для крутанов
    -   Автор закинул удочку, что Executor лучший в мире интерфейс
-   6.2.1. Пример: веб-сервер с использованием Executor
    -   все что я понял, Executor поддерживает встроенный pool потоков. Прям при ините можно указать
-   6.2.2. Политики выполнения
    -   перед проекитрованием стоит выбрать политику исполнения, которая должна отвечать на следующие вопросы
        -   В каком потоке будут выполняться задачи?
        -   Каков порядок выполнения задач (FIFO, LIFO, приоритетный порядок)?
        -   Сколько задач может выполняться конкурентно?
        -   Сколько задач может быть поставлено в очередь?
        -   Какую задачу удалить из-за перегрузки системы и как уведомить приложение?
        -   Какие действия предпринимать до и после выполнения задачи?
-   6.2.3. Пулы потоков
    -   в Executor можно определить логику работы pool-ов
        -   newFixedThreadPool
            -   Пул потоков фиксированного размера
            -   создает определенное число потоков по мере предоставления задач
            -   старается держать размер пула постоянным
        -   newCachedThreadPool
            -   Более гибкий кэшированный пул потоков
            -   убирает простаивающие потоки и при необходимости добавляет новые
            -   не накладывая лимит на размер пула.
        -   newSingleThreadExecutor
            -   Исполнитель создает один поток для последовательной обработки задач, который при необходимости можно заменить
        -   newScheduledThreadPool
            -   пул потоков фиксированного размера
            -   периодическое выполнение задач аналогично классу Timer
-   6.2.4. Жизненный цикл исполнителя Executor
    -   Executor - отключается когда все потоки терминированы
    -   ExecutorService - расширяет executor добавляя контроль жизненного цикла. Имеет три состояния: работает, выключается и терминирован
    -   LifecycleWebServer - добавляет поддержку жизненного цикла web серверу
-   6.2.5. Отложенные и периодические задачи
    -   Timer - выполняет переодические и отложенные задачи, но имеет проблемы:
        -   если TimerTask должна выполняться каждые 10мс, а другой TimerTask выполняется 40мс, то первый либо не выполнится ни разу, либо по завершению второй, сразу четыре раза подряд
        -   если TImerTask включающийся с периодичностью - один раз упал, то следующих запланированных запусков не случится вообще
        -   поддерживает только абсолютное время, из-за чего смена часового пояса ломает Timer
    -   ScheduledThreadPoolExecutor - альтернатива Timer
        -   поддерживает только относительное время
-   6.3. Поиск эксплуатационно-пригодного параллелизма
-   6.3.1. Пример: последовательный страничный отрисовщик
-   6.3.2. Задачи, приносящие результаты: Callable и Future
    -   есть Runnable, который не возвращает результат
    -   есть Callable, который способен вернут результат отложенных вычеслений
    -   есть Future, который способен вернуть результат, проверить бала ли задача решена и еще прервать выполнение задачи
-   6.3.3. Пример: страничный отрисовщик с объектом Future
-   6.3.4. Ограничения параллелизации разнородных задач
    -   вернемся к пример с мойкой посуды
        -   работник А моет посуду, работник Б расставляет помытую посуду
        -   если мойка посуды занимает в 10 раз больше ресурсов, чем ее расстановка, то от расспаралеливания задачи мы ничего не выйграли
        -   выгоднее поставить обоих работников поставить мыть посуду
    -   чтобы параллельное выполнение задачи было выгодно, нужно чтобы задачи были
        -   независимыми
        -   однородными по затраченным ресурсам
        -   количество выгранового времени было больше, чем потрачено на создание потока
-   6.3.5. CompletionService: исполнитель Executor встречается с очередью BlockingQueue
    -   а встречаются они в ExecutorCompletionService
    -   позволяет извлекать результаты по мере выполнения распараллеленых задач
-   6.3.6. Пример: страничный отрисовщик со службой CompletionService
-   6.3.7. Наложение временнˆых ограничений на задачи
    -   Future можно использовать с тайм-аутом
-   6.3.8. Пример: портал бронирования поездок
-   7 Отмена и выключение
-   7.1. Отмена задачи
    -   в java это сделано просто, мы задаем флаг отмены, а задача должна по флагу сама определить что ей пора завершиться
-   7.1.1. Прерывание
    -   есть специальный метод, interrupt. По идее вызывает в потоке ошибку InterruptedException
    -   в плохих реализациях, классы не реагируют и програлатывают ошибку
    -   встроенные библиотечные методы, хорошо отзываеются на прерывание через специальный метод interrupt, то бишь падают
    -   бывают ситуации, когда работу по другому не прервать
-   7.1.2. Политики прерывания
    -   в главе делается большой акцент, что не задаче выделяется поток, а в выделенный поток помещается задача
    -   поток должен выключаться только его владельцем(pull-потоков), который знает о политике прерывания потока
    -   автор рекомендует, в качестве политики прерываниявыбрать отмену на уровне потока
-   7.1.3. Отклик на прерывание
    -   первый случай: прокидываем throw выше по стеку, чтобы стек мог отработать исключение
    -   второй случай: ставим флаг Thread.CurrentThread().interrupt(), чтобы стек выше мог узнать, что что-то прерывается
    -   но вообще, я ничего не понял...
-   7.1.4. Пример: хронометрированный прогон
    -   чтобы отменить задачу через секунду после начала выполнения, не надо создавать другой поток(таймер) внутри задачи
        -   это может привести к тому, что если задача закончится быстрее таймера, то таймер уронит приложение
        -   поэтому чтобы отменить поток, нужно еще не забыть отменить отмену потока )
-   7.1.5. Отмена с помощью Future
    -   поток_1.join(поток_2) - поток_1(это не точно) будет заблокирован до отработки поток_2
    -   автор предлагает делать примерно следующее, но я как обычно ничерта не понимаю

```java
public static void timedRun(Runnable r,
                            long timeout, TimeUnit unit)
                            throws InterruptedException {
    Future<?> task = taskExec.submit(r);
    try {
        task.get(timeout, unit);
    } catch (TimeoutException e) {
        // задача будет отменена ниже
    } catch (ExecutionException e) {
        // исключение выдано в задаче; выдать повторно
        throw launderThrowable(e.getCause());
    } finally {
        // Безвредно, если задача уже завершена
        task.cancel(true); // прервать, если работает
    }
}
```

-   7.1.6. Работа с непрерываемым блокированием
    -   работа с сокетами(ввод-вывод) является непрерываемой операцией
    -   чтобы убедить поток остановиться, когда он работает с непрерывемой операцией нужно понимать:
        -   закрытие базового сокета при синхронном вводве-выводе в java.io - приводит к SocketException
        -   закрытие базового сокета при синхронном вводве-выводе в java.nio - приводит к AsynchronousCloseException
        -   ...
-   7.1.7 Инкапсуляция нестандартной отмены с помощью newTaskFor
    -   newTaskFor это фабричный метод, который возвращает Future обернутый в RunnableFuture интерфейс, в котором есть метод cancel, отменяющий работу таски(потока?)
-   7.2. Остановка поточной службы
    -   приложение знает о сервисе -> сервис знает о потоках
        -   следовательно, приложение не знает о потоках
-   7.2.1. Пример: служба журналирования
    -   Автор рассказывает, что обычно служба журнала, подразумевает отдельные потоки и при выключении может залочить другие потоки
    -   но честно говоря, я опять ничего не понял )
-   7.2.2. Выключение службы ExecutorService
    -   автор говорит, что стоит предусмотреть несколько режимов выключения, жесткий (ShutdownNow) и более плавны(Shutdown)
-   7.2.3. Ядовитые таблетки
    -   вместо прерывания потока через вызов interrupt, можно создать "ядовитую таблетку"
    -   "ядовитая таблетка" - объект, начав работать с которым, поток просто прерывается
-   7.2.4. Пример: служба однократного выполнен
    -   вода какая-то
-   7.2.5. Ограничения метода shutdownNow
    -   Предполагается, что при выключении вы захотите знать, в каком состоянии были задачи
    -   Вроде не проблема и очень даже решаемо, почему глава называется ограничения - загадка
-   7.3. Обработка аномальной терминации потоков
    -   Когда падает однопоточное приложение, то это очевидно роняет приложение, когда падает поток, об этом можно и не узнать вообще
    -   Но даже так, запуск Runnable оборачивают в try...catch толь ко очень ненадежный код
        -   например, подгружаемы на ходу классы
    -   в остальном, менеджер потоков должен просто быть оповещен, что все упало(а как, я хз)
-   7.3.1. Обработчики неотловленных исключений
    -   чтобы обробатывать неотловленные исключения, существует специальный интерфейс - UncaughtExceptionHandler
    -   UncaughtExceptionHandler должен имплементировать только владелец потока
    -   можно даже зареранить поток через этот интерфейсэ
-   7.4. Выключение JVM
    -   если нет потоков - jvm выключается. Это предпочтительный вариант
    -   А как выключаться при Runtime.halt или SIGKILL
-   7.4.1. Хуки
    -   хуки
        -   jvm перед выключением запускает хуки, которые зарегистрированы с помощью метода Runtime.addShutdownHook
        -   хуки, а вернее shutdown hooks - это отдельные потоки
    -   финализаторы
        -   хуки помеченные флажком runFinalizersOnExit
    -   если хук или финализатор - зависли, то jvm не выключится

Пример регестрации хука:

```java
public void start() {
 Runtime.getRuntime().addShutdownHook(new Thread() {
 public void run() {
 try { LogService.this.stop(); }
 catch (InterruptedException ignored) {}
 }
 });
}
```

-   7.4.2. Потоки-демоны
    -   Потоки-демон - вспомогательный поток, который игнорируется jvm при выключении jvm
    -   к потокам демонам например, относятся например: сборщик мусора
    -   Есть два правила для решения, какой демон-статус имеет поток
        -   поток наследует демон-статус создавшего его потока
        -   только главный поток имеет статус нормального-потока
-   8 - Применение пулов потоков
-   8.1. Неявные стыковки между задачами и политиками выполнения
    -   вернемся к нашим баранам - задачи должны быть однородны и независимы
-   8.1.1. Взаимная блокировка с ресурсным голоданием
    -   лимит пула, может быть определен зависимыми задачами
        -   например, есть пул из 10 подключений к БД, и есть задачи зависимые от БД. Значит пул для задач - 10
-   8.1.2. Длительные задачи
    -   если длительных задач, больше чем пул, может получиться так, что приложение застопорится, из-за заполненого пула задачами, которые не могут завершиться
    -   решение - используй хронометрированные версии классов и ставь тайм-ауты
-   8.2. Определение размера пула потоков
    -   в этой главе на удивление много конкретики
    -   для вычислительно емких задач, размер пула:
        -   $$N_cpu + 1$$
            -   N_cpu - число процессоров
        -   +1 , потому что даже вычислительно мощные потоки бывает делают отказы или берут паузу
    -   Для задач с использованием ввода вывода, требуется большой пул, вычисляемый по формуле:
        -   N_потоков = N_cpu _ U_cpu _ (1 + \frac{W}{C})
            -   N_cpu - число процессоров
                -   можно определить через int N_CPU = Runtime.getRuntime().availableProcessors();
            -   U_cpu - = целевая задействованность процессоров, от 0 до 1
            -   W - время ожидания
            -   C - время вычисления
    -   ну и надо помнить, что всякие БД тоже отжирают производительность
-   8.3. Конфигурирование класса ThreadPoolExecutor
    -   базовая реализация исполнителей, которую можно настроить под себя
-   8.3.1. Создание и удаление потоков
-   8.3.2. Управление задачами очереди
-   ...
-   8.4. Расширение класса ThreadPoolExecutor
